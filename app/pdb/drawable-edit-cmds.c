/* LIGMA - The GNU Image Manipulation Program
 * Copyright (C) 1995-2003 Spencer Kimball and Peter Mattis
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

/* NOTE: This file is auto-generated by pdbgen.pl. */

#include "config.h"

#include "stamp-pdbgen.h"

#include <gegl.h>

#include <gdk-pixbuf/gdk-pixbuf.h>

#include "libligmaconfig/ligmaconfig.h"

#include "libligmabase/ligmabase.h"

#include "pdb-types.h"

#include "core/ligma-gradients.h"
#include "core/ligma.h"
#include "core/ligmabuffer.h"
#include "core/ligmadrawable-bucket-fill.h"
#include "core/ligmadrawable-edit.h"
#include "core/ligmadrawable-gradient.h"
#include "core/ligmadrawable.h"
#include "core/ligmaimage.h"
#include "core/ligmaitem.h"
#include "core/ligmaparamspecs.h"
#include "core/ligmaprogress.h"
#include "core/ligmastrokeoptions.h"
#include "paint/ligmapaintoptions.h"

#include "ligmapdb.h"
#include "ligmapdb-utils.h"
#include "ligmapdbcontext.h"
#include "ligmaprocedure.h"
#include "internal-procs.h"

#include "ligma-intl.h"


static LigmaValueArray *
drawable_edit_clear_invoker (LigmaProcedure         *procedure,
                             Ligma                  *ligma,
                             LigmaContext           *context,
                             LigmaProgress          *progress,
                             const LigmaValueArray  *args,
                             GError               **error)
{
  gboolean success = TRUE;
  LigmaDrawable *drawable;

  drawable = g_value_get_object (ligma_value_array_index (args, 0));

  if (success)
    {
      if (ligma_pdb_item_is_attached (LIGMA_ITEM (drawable), NULL,
                                     LIGMA_PDB_ITEM_CONTENT, error) &&
          ligma_pdb_item_is_not_group (LIGMA_ITEM (drawable), error))
        {
          ligma_drawable_edit_clear (drawable, context);
        }
      else
        success = FALSE;
    }

  return ligma_procedure_get_return_values (procedure, success,
                                           error ? *error : NULL);
}

static LigmaValueArray *
drawable_edit_fill_invoker (LigmaProcedure         *procedure,
                            Ligma                  *ligma,
                            LigmaContext           *context,
                            LigmaProgress          *progress,
                            const LigmaValueArray  *args,
                            GError               **error)
{
  gboolean success = TRUE;
  LigmaDrawable *drawable;
  gint fill_type;

  drawable = g_value_get_object (ligma_value_array_index (args, 0));
  fill_type = g_value_get_enum (ligma_value_array_index (args, 1));

  if (success)
    {
      if (ligma_pdb_item_is_attached (LIGMA_ITEM (drawable), NULL,
                                     LIGMA_PDB_ITEM_CONTENT, error) &&
          ligma_pdb_item_is_not_group (LIGMA_ITEM (drawable), error))
        {
          LigmaFillOptions *options = ligma_fill_options_new (ligma, NULL, FALSE);

          ligma_context_set_opacity (LIGMA_CONTEXT (options),
                                    ligma_context_get_opacity (context));
          ligma_context_set_paint_mode (LIGMA_CONTEXT (options),
                                       ligma_context_get_paint_mode (context));

          if (ligma_fill_options_set_by_fill_type (options, context,
                                                  fill_type, error))
            {
              ligma_drawable_edit_fill (drawable, options, NULL);
            }
          else
            success = FALSE;

          g_object_unref (options);
        }
      else
        success = FALSE;
    }

  return ligma_procedure_get_return_values (procedure, success,
                                           error ? *error : NULL);
}

static LigmaValueArray *
drawable_edit_bucket_fill_invoker (LigmaProcedure         *procedure,
                                   Ligma                  *ligma,
                                   LigmaContext           *context,
                                   LigmaProgress          *progress,
                                   const LigmaValueArray  *args,
                                   GError               **error)
{
  gboolean success = TRUE;
  LigmaDrawable *drawable;
  gint fill_type;
  gdouble x;
  gdouble y;

  drawable = g_value_get_object (ligma_value_array_index (args, 0));
  fill_type = g_value_get_enum (ligma_value_array_index (args, 1));
  x = g_value_get_double (ligma_value_array_index (args, 2));
  y = g_value_get_double (ligma_value_array_index (args, 3));

  if (success)
    {
      if (ligma_pdb_item_is_attached (LIGMA_ITEM (drawable), NULL,
                                     LIGMA_PDB_ITEM_CONTENT, error) &&
          ligma_pdb_item_is_not_group (LIGMA_ITEM (drawable), error))
        {
          LigmaFillOptions *options = ligma_fill_options_new (ligma, NULL, FALSE);

          ligma_context_set_opacity (LIGMA_CONTEXT (options),
                                    ligma_context_get_opacity (context));
          ligma_context_set_paint_mode (LIGMA_CONTEXT (options),
                                       ligma_context_get_paint_mode (context));

          ligma_fill_options_set_antialias (options,
                                           LIGMA_PDB_CONTEXT (context)->antialias);

          if (ligma_fill_options_set_by_fill_type (options, context,
                                                  fill_type, error))
            {
              ligma_drawable_bucket_fill (drawable, options,
                                         LIGMA_PDB_CONTEXT (context)->sample_transparent,
                                         LIGMA_PDB_CONTEXT (context)->sample_criterion,
                                         LIGMA_PDB_CONTEXT (context)->sample_threshold,
                                         LIGMA_PDB_CONTEXT (context)->sample_merged,
                                         LIGMA_PDB_CONTEXT (context)->diagonal_neighbors,
                                         x, y);
            }
          else
            success = FALSE;

          g_object_unref (options);
        }
      else
        success = FALSE;
    }

  return ligma_procedure_get_return_values (procedure, success,
                                           error ? *error : NULL);
}

static LigmaValueArray *
drawable_edit_gradient_fill_invoker (LigmaProcedure         *procedure,
                                     Ligma                  *ligma,
                                     LigmaContext           *context,
                                     LigmaProgress          *progress,
                                     const LigmaValueArray  *args,
                                     GError               **error)
{
  gboolean success = TRUE;
  LigmaDrawable *drawable;
  gint gradient_type;
  gdouble offset;
  gboolean supersample;
  gint supersample_max_depth;
  gdouble supersample_threshold;
  gboolean dither;
  gdouble x1;
  gdouble y1;
  gdouble x2;
  gdouble y2;

  drawable = g_value_get_object (ligma_value_array_index (args, 0));
  gradient_type = g_value_get_enum (ligma_value_array_index (args, 1));
  offset = g_value_get_double (ligma_value_array_index (args, 2));
  supersample = g_value_get_boolean (ligma_value_array_index (args, 3));
  supersample_max_depth = g_value_get_int (ligma_value_array_index (args, 4));
  supersample_threshold = g_value_get_double (ligma_value_array_index (args, 5));
  dither = g_value_get_boolean (ligma_value_array_index (args, 6));
  x1 = g_value_get_double (ligma_value_array_index (args, 7));
  y1 = g_value_get_double (ligma_value_array_index (args, 8));
  x2 = g_value_get_double (ligma_value_array_index (args, 9));
  y2 = g_value_get_double (ligma_value_array_index (args, 10));

  if (success)
    {
      success = (ligma_pdb_item_is_attached (LIGMA_ITEM (drawable), NULL,
                                            LIGMA_PDB_ITEM_CONTENT, error) &&
                 ligma_pdb_item_is_not_group (LIGMA_ITEM (drawable), error));

      if (success)
        {
          if (supersample)
            {
              if (supersample_max_depth < 1 || supersample_max_depth > 9)
                success = FALSE;

              if (supersample_threshold < 0.0 || supersample_threshold > 4.0)
                success = FALSE;
            }
          else
            {
              supersample_max_depth = CLAMP (supersample_max_depth, 1, 9);
              supersample_threshold = CLAMP (supersample_threshold, 0.0, 4.0);
            }
       }

      if (success)
        {
          /* all options should have the same value, so pick a random one */
          LigmaPaintOptions *options =
            ligma_pdb_context_get_paint_options (LIGMA_PDB_CONTEXT (context),
                                                "ligma-paintbrush");

          if (progress)
            ligma_progress_start (progress, FALSE, _("Gradient"));

          ligma_drawable_gradient (drawable,
                                  context,
                                  ligma_context_get_gradient (context),
                                  LIGMA_PDB_CONTEXT (context)->distance_metric,
                                  ligma_context_get_paint_mode (context),
                                  gradient_type,
                                  ligma_context_get_opacity (context),
                                  offset,
                                  options->gradient_options->gradient_repeat,
                                  options->gradient_options->gradient_reverse,
                                  options->gradient_options->gradient_blend_color_space,
                                  supersample,
                                  supersample_max_depth,
                                  supersample_threshold,
                                  dither,
                                  x1, y1, x2, y2,
                                  progress);

          if (progress)
            ligma_progress_end (progress);
        }
    }

  return ligma_procedure_get_return_values (procedure, success,
                                           error ? *error : NULL);
}

static LigmaValueArray *
drawable_edit_stroke_selection_invoker (LigmaProcedure         *procedure,
                                        Ligma                  *ligma,
                                        LigmaContext           *context,
                                        LigmaProgress          *progress,
                                        const LigmaValueArray  *args,
                                        GError               **error)
{
  gboolean success = TRUE;
  LigmaDrawable *drawable;

  drawable = g_value_get_object (ligma_value_array_index (args, 0));

  if (success)
    {
      if (ligma_pdb_item_is_attached (LIGMA_ITEM (drawable), NULL,
                                     LIGMA_PDB_ITEM_CONTENT, error) &&
          ligma_pdb_item_is_not_group (LIGMA_ITEM (drawable), error))
        {
          LigmaImage         *image = ligma_item_get_image (LIGMA_ITEM (drawable));
          LigmaStrokeOptions *options;
          LigmaPaintOptions  *paint_options;
          GList             *drawables = g_list_prepend (NULL, drawable);

          options = ligma_pdb_context_get_stroke_options (LIGMA_PDB_CONTEXT (context));

          paint_options =
            ligma_pdb_context_get_paint_options (LIGMA_PDB_CONTEXT (context), NULL);
          paint_options = ligma_config_duplicate (LIGMA_CONFIG (paint_options));

          success = ligma_item_stroke (LIGMA_ITEM (ligma_image_get_mask (image)),
                                      drawables, context, options, paint_options,
                                      TRUE, progress, error);

          g_object_unref (paint_options);
          g_list_free (drawables);
        }
      else
        success = FALSE;
    }

  return ligma_procedure_get_return_values (procedure, success,
                                           error ? *error : NULL);
}

static LigmaValueArray *
drawable_edit_stroke_item_invoker (LigmaProcedure         *procedure,
                                   Ligma                  *ligma,
                                   LigmaContext           *context,
                                   LigmaProgress          *progress,
                                   const LigmaValueArray  *args,
                                   GError               **error)
{
  gboolean success = TRUE;
  LigmaDrawable *drawable;
  LigmaItem *item;

  drawable = g_value_get_object (ligma_value_array_index (args, 0));
  item = g_value_get_object (ligma_value_array_index (args, 1));

  if (success)
    {
      if (ligma_pdb_item_is_attached (LIGMA_ITEM (drawable), NULL,
                                     LIGMA_PDB_ITEM_CONTENT, error) &&
          ligma_pdb_item_is_not_group (LIGMA_ITEM (drawable), error) &&
          ligma_pdb_item_is_attached (item,
                                     ligma_item_get_image (LIGMA_ITEM (drawable)),
                                     0, error))
        {
          LigmaStrokeOptions *options;
          LigmaPaintOptions  *paint_options;
          GList             *drawables = g_list_prepend (NULL, drawable);

          options = ligma_pdb_context_get_stroke_options (LIGMA_PDB_CONTEXT (context));

          paint_options =
            ligma_pdb_context_get_paint_options (LIGMA_PDB_CONTEXT (context), NULL);
          paint_options = ligma_config_duplicate (LIGMA_CONFIG (paint_options));

          success = ligma_item_stroke (item, drawables,
                                      context, options, paint_options,
                                      TRUE, progress, error);

          g_object_unref (paint_options);
          g_list_free (drawables);
        }
      else
        success = FALSE;
    }

  return ligma_procedure_get_return_values (procedure, success,
                                           error ? *error : NULL);
}

void
register_drawable_edit_procs (LigmaPDB *pdb)
{
  LigmaProcedure *procedure;

  /*
   * ligma-drawable-edit-clear
   */
  procedure = ligma_procedure_new (drawable_edit_clear_invoker);
  ligma_object_set_static_name (LIGMA_OBJECT (procedure),
                               "ligma-drawable-edit-clear");
  ligma_procedure_set_static_help (procedure,
                                  "Clear selected area of drawable.",
                                  "This procedure clears the specified drawable. If the drawable has an alpha channel, the cleared pixels will become transparent. If the drawable does not have an alpha channel, cleared pixels will be set to the background color. This procedure only affects regions within a selection if there is a selection active.\n"
                                  "\n"
                                  "This procedure is affected by the following context setters: 'ligma-context-set-background'.",
                                  NULL);
  ligma_procedure_set_static_attribution (procedure,
                                         "Spencer Kimball & Peter Mattis",
                                         "Spencer Kimball & Peter Mattis",
                                         "1995-1996");
  ligma_procedure_add_argument (procedure,
                               ligma_param_spec_drawable ("drawable",
                                                         "drawable",
                                                         "The drawable to clear from",
                                                         FALSE,
                                                         LIGMA_PARAM_READWRITE));
  ligma_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * ligma-drawable-edit-fill
   */
  procedure = ligma_procedure_new (drawable_edit_fill_invoker);
  ligma_object_set_static_name (LIGMA_OBJECT (procedure),
                               "ligma-drawable-edit-fill");
  ligma_procedure_set_static_help (procedure,
                                  "Fill selected area of drawable.",
                                  "This procedure fills the specified drawable according to fill mode. This procedure only affects regions within a selection if there is a selection active. If you want to fill the whole drawable, regardless of the selection, use 'ligma-drawable-fill'.\n"
                                  "\n"
                                  "This procedure is affected by the following context setters: 'ligma-context-set-opacity', 'ligma-context-set-paint-mode', 'ligma-context-set-foreground', 'ligma-context-set-background', 'ligma-context-set-pattern'.",
                                  NULL);
  ligma_procedure_set_static_attribution (procedure,
                                         "Spencer Kimball & Peter Mattis & Raphael Quinet",
                                         "Spencer Kimball & Peter Mattis",
                                         "1995-2000");
  ligma_procedure_add_argument (procedure,
                               ligma_param_spec_drawable ("drawable",
                                                         "drawable",
                                                         "The drawable to fill to",
                                                         FALSE,
                                                         LIGMA_PARAM_READWRITE));
  ligma_procedure_add_argument (procedure,
                               g_param_spec_enum ("fill-type",
                                                  "fill type",
                                                  "The type of fill",
                                                  LIGMA_TYPE_FILL_TYPE,
                                                  LIGMA_FILL_FOREGROUND,
                                                  LIGMA_PARAM_READWRITE));
  ligma_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * ligma-drawable-edit-bucket-fill
   */
  procedure = ligma_procedure_new (drawable_edit_bucket_fill_invoker);
  ligma_object_set_static_name (LIGMA_OBJECT (procedure),
                               "ligma-drawable-edit-bucket-fill");
  ligma_procedure_set_static_help (procedure,
                                  "Fill the area by a seed fill starting at the specified coordinates.",
                                  "This procedure does a seed fill at the specified coordinates, using various parameters from the current context.\n"
                                  "In the case of merged sampling, the x and y coordinates are relative to the image's origin; otherwise, they are relative to the drawable's origin.\n"
                                  "\n"
                                  "This procedure is affected by the following context setters: 'ligma-context-set-opacity', 'ligma-context-set-paint-mode', 'ligma-context-set-foreground', 'ligma-context-set-background', 'ligma-context-set-pattern', 'ligma-context-set-sample-threshold', 'ligma-context-set-sample-merged', 'ligma-context-set-sample-criterion', 'ligma-context-set-diagonal-neighbors', 'ligma-context-set-antialias'.",
                                  NULL);
  ligma_procedure_set_static_attribution (procedure,
                                         "Michael Natterer <mitch@ligma.org>",
                                         "Michael Natterer",
                                         "2018");
  ligma_procedure_add_argument (procedure,
                               ligma_param_spec_drawable ("drawable",
                                                         "drawable",
                                                         "The affected drawable",
                                                         FALSE,
                                                         LIGMA_PARAM_READWRITE));
  ligma_procedure_add_argument (procedure,
                               g_param_spec_enum ("fill-type",
                                                  "fill type",
                                                  "The type of fill",
                                                  LIGMA_TYPE_FILL_TYPE,
                                                  LIGMA_FILL_FOREGROUND,
                                                  LIGMA_PARAM_READWRITE));
  ligma_procedure_add_argument (procedure,
                               g_param_spec_double ("x",
                                                    "x",
                                                    "The x coordinate of this bucket fill's application.",
                                                    -G_MAXDOUBLE, G_MAXDOUBLE, 0,
                                                    LIGMA_PARAM_READWRITE));
  ligma_procedure_add_argument (procedure,
                               g_param_spec_double ("y",
                                                    "y",
                                                    "The y coordinate of this bucket fill's application.",
                                                    -G_MAXDOUBLE, G_MAXDOUBLE, 0,
                                                    LIGMA_PARAM_READWRITE));
  ligma_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * ligma-drawable-edit-gradient-fill
   */
  procedure = ligma_procedure_new (drawable_edit_gradient_fill_invoker);
  ligma_object_set_static_name (LIGMA_OBJECT (procedure),
                               "ligma-drawable-edit-gradient-fill");
  ligma_procedure_set_static_help (procedure,
                                  "Draw a gradient between the starting and ending coordinates with the specified gradient type.",
                                  "This tool requires information on the gradient type. It creates the specified variety of gradient using the starting and ending coordinates as defined for each gradient type. For shapeburst gradient types, the context's distance metric is also relevant and can be updated with 'ligma-context-set-distance-metric'.\n"
                                  "\n"
                                  "This procedure is affected by the following context setters: 'ligma-context-set-opacity', 'ligma-context-set-paint-mode', 'ligma-context-set-foreground', 'ligma-context-set-background', 'ligma-context-set-gradient' and all gradient property settings, 'ligma-context-set-distance-metric'.",
                                  NULL);
  ligma_procedure_set_static_attribution (procedure,
                                         "Michael Natterer <mitch@ligma.org>",
                                         "Michael Natterer",
                                         "2018");
  ligma_procedure_add_argument (procedure,
                               ligma_param_spec_drawable ("drawable",
                                                         "drawable",
                                                         "The affected drawable",
                                                         FALSE,
                                                         LIGMA_PARAM_READWRITE));
  ligma_procedure_add_argument (procedure,
                               g_param_spec_enum ("gradient-type",
                                                  "gradient type",
                                                  "The type of gradient",
                                                  LIGMA_TYPE_GRADIENT_TYPE,
                                                  LIGMA_GRADIENT_LINEAR,
                                                  LIGMA_PARAM_READWRITE));
  ligma_procedure_add_argument (procedure,
                               g_param_spec_double ("offset",
                                                    "offset",
                                                    "Offset relates to the starting and ending coordinates specified for the blend. This parameter is mode dependent.",
                                                    0, G_MAXDOUBLE, 0,
                                                    LIGMA_PARAM_READWRITE));
  ligma_procedure_add_argument (procedure,
                               g_param_spec_boolean ("supersample",
                                                     "supersample",
                                                     "Do adaptive supersampling",
                                                     FALSE,
                                                     LIGMA_PARAM_READWRITE));
  ligma_procedure_add_argument (procedure,
                               g_param_spec_int ("supersample-max-depth",
                                                 "supersample max depth",
                                                 "Maximum recursion levels for supersampling",
                                                 1, 9, 1,
                                                 LIGMA_PARAM_READWRITE | LIGMA_PARAM_NO_VALIDATE));
  ligma_procedure_add_argument (procedure,
                               g_param_spec_double ("supersample-threshold",
                                                    "supersample threshold",
                                                    "Supersampling threshold",
                                                    0, 4, 0,
                                                    LIGMA_PARAM_READWRITE | LIGMA_PARAM_NO_VALIDATE));
  ligma_procedure_add_argument (procedure,
                               g_param_spec_boolean ("dither",
                                                     "dither",
                                                     "Use dithering to reduce banding",
                                                     FALSE,
                                                     LIGMA_PARAM_READWRITE));
  ligma_procedure_add_argument (procedure,
                               g_param_spec_double ("x1",
                                                    "x1",
                                                    "The x coordinate of this gradient's starting point",
                                                    -G_MAXDOUBLE, G_MAXDOUBLE, 0,
                                                    LIGMA_PARAM_READWRITE));
  ligma_procedure_add_argument (procedure,
                               g_param_spec_double ("y1",
                                                    "y1",
                                                    "The y coordinate of this gradient's starting point",
                                                    -G_MAXDOUBLE, G_MAXDOUBLE, 0,
                                                    LIGMA_PARAM_READWRITE));
  ligma_procedure_add_argument (procedure,
                               g_param_spec_double ("x2",
                                                    "x2",
                                                    "The x coordinate of this gradient's ending point",
                                                    -G_MAXDOUBLE, G_MAXDOUBLE, 0,
                                                    LIGMA_PARAM_READWRITE));
  ligma_procedure_add_argument (procedure,
                               g_param_spec_double ("y2",
                                                    "y2",
                                                    "The y coordinate of this gradient's ending point",
                                                    -G_MAXDOUBLE, G_MAXDOUBLE, 0,
                                                    LIGMA_PARAM_READWRITE));
  ligma_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * ligma-drawable-edit-stroke-selection
   */
  procedure = ligma_procedure_new (drawable_edit_stroke_selection_invoker);
  ligma_object_set_static_name (LIGMA_OBJECT (procedure),
                               "ligma-drawable-edit-stroke-selection");
  ligma_procedure_set_static_help (procedure,
                                  "Stroke the current selection",
                                  "This procedure strokes the current selection, painting along the selection boundary with the active paint method and brush, or using a plain line with configurable properties. The paint is applied to the specified drawable regardless of the active selection.\n"
                                  "\n"
                                  "This procedure is affected by the following context setters: 'ligma-context-set-opacity', 'ligma-context-set-paint-mode', 'ligma-context-set-paint-method', 'ligma-context-set-stroke-method', 'ligma-context-set-foreground', 'ligma-context-set-brush' and all brush property settings, 'ligma-context-set-gradient' and all gradient property settings, 'ligma-context-set-line-width' and all line property settings, 'ligma-context-set-antialias'.",
                                  NULL);
  ligma_procedure_set_static_attribution (procedure,
                                         "Spencer Kimball & Peter Mattis",
                                         "Spencer Kimball & Peter Mattis",
                                         "1995-1996");
  ligma_procedure_add_argument (procedure,
                               ligma_param_spec_drawable ("drawable",
                                                         "drawable",
                                                         "The drawable to stroke to",
                                                         FALSE,
                                                         LIGMA_PARAM_READWRITE));
  ligma_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * ligma-drawable-edit-stroke-item
   */
  procedure = ligma_procedure_new (drawable_edit_stroke_item_invoker);
  ligma_object_set_static_name (LIGMA_OBJECT (procedure),
                               "ligma-drawable-edit-stroke-item");
  ligma_procedure_set_static_help (procedure,
                                  "Stroke the specified item",
                                  "This procedure strokes the specified item, painting along its outline (e.g. along a path, or along a channel's boundary), with the active paint method and brush, or using a plain line with configurable properties.\n"
                                  "\n"
                                  "This procedure is affected by the following context setters: 'ligma-context-set-opacity', 'ligma-context-set-paint-mode', 'ligma-context-set-paint-method', 'ligma-context-set-stroke-method', 'ligma-context-set-foreground', 'ligma-context-set-brush' and all brush property settings, 'ligma-context-set-gradient' and all gradient property settings, 'ligma-context-set-line-width' and all line property settings, 'ligma-context-set-antialias'.",
                                  NULL);
  ligma_procedure_set_static_attribution (procedure,
                                         "Michael Natterer <mitch@ligma.org>",
                                         "Michael Natterer",
                                         "2018");
  ligma_procedure_add_argument (procedure,
                               ligma_param_spec_drawable ("drawable",
                                                         "drawable",
                                                         "The drawable to stroke to",
                                                         FALSE,
                                                         LIGMA_PARAM_READWRITE));
  ligma_procedure_add_argument (procedure,
                               ligma_param_spec_item ("item",
                                                     "item",
                                                     "The item to stroke",
                                                     FALSE,
                                                     LIGMA_PARAM_READWRITE));
  ligma_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);
}
