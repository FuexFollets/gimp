/* LIGMA - The GNU Image Manipulation Program
 * Copyright (C) 1995-2003 Spencer Kimball and Peter Mattis
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

/* NOTE: This file is auto-generated by pdbgen.pl. */

#include "config.h"

#include "stamp-pdbgen.h"

#include <gegl.h>

#include <gdk-pixbuf/gdk-pixbuf.h>

#include "libligmabase/ligmabase.h"

#include "pdb-types.h"

#include "core/ligmaimage-sample-points.h"
#include "core/ligmaimage.h"
#include "core/ligmaparamspecs.h"
#include "core/ligmasamplepoint.h"

#include "ligmapdb.h"
#include "ligmapdberror.h"
#include "ligmapdb-utils.h"
#include "ligmaprocedure.h"
#include "internal-procs.h"

#include "ligma-intl.h"


static LigmaValueArray *
image_add_sample_point_invoker (LigmaProcedure         *procedure,
                                Ligma                  *ligma,
                                LigmaContext           *context,
                                LigmaProgress          *progress,
                                const LigmaValueArray  *args,
                                GError               **error)
{
  gboolean success = TRUE;
  LigmaValueArray *return_vals;
  LigmaImage *image;
  gint position_x;
  gint position_y;
  guint sample_point = 0;

  image = g_value_get_object (ligma_value_array_index (args, 0));
  position_x = g_value_get_int (ligma_value_array_index (args, 1));
  position_y = g_value_get_int (ligma_value_array_index (args, 2));

  if (success)
    {
      if (position_x <= ligma_image_get_width  (image) &&
          position_y <= ligma_image_get_height (image))
        {
          LigmaSamplePoint *sp;

          sp = ligma_image_add_sample_point_at_pos (image, position_x, position_y,
                                                   TRUE);
          sample_point = ligma_aux_item_get_id (LIGMA_AUX_ITEM (sp));
        }
      else
        success = FALSE;
    }

  return_vals = ligma_procedure_get_return_values (procedure, success,
                                                  error ? *error : NULL);

  if (success)
    g_value_set_uint (ligma_value_array_index (return_vals, 1), sample_point);

  return return_vals;
}

static LigmaValueArray *
image_delete_sample_point_invoker (LigmaProcedure         *procedure,
                                   Ligma                  *ligma,
                                   LigmaContext           *context,
                                   LigmaProgress          *progress,
                                   const LigmaValueArray  *args,
                                   GError               **error)
{
  gboolean success = TRUE;
  LigmaImage *image;
  guint sample_point;

  image = g_value_get_object (ligma_value_array_index (args, 0));
  sample_point = g_value_get_uint (ligma_value_array_index (args, 1));

  if (success)
    {
      LigmaSamplePoint *sp = ligma_pdb_image_get_sample_point (image, sample_point,
                                                             error);

      if (sp)
        ligma_image_remove_sample_point (image, sp, TRUE);
      else
        success = FALSE;
    }

  return ligma_procedure_get_return_values (procedure, success,
                                           error ? *error : NULL);
}

static LigmaValueArray *
image_find_next_sample_point_invoker (LigmaProcedure         *procedure,
                                      Ligma                  *ligma,
                                      LigmaContext           *context,
                                      LigmaProgress          *progress,
                                      const LigmaValueArray  *args,
                                      GError               **error)
{
  gboolean success = TRUE;
  LigmaValueArray *return_vals;
  LigmaImage *image;
  guint sample_point;
  guint next_sample_point = 0;

  image = g_value_get_object (ligma_value_array_index (args, 0));
  sample_point = g_value_get_uint (ligma_value_array_index (args, 1));

  if (success)
    {
      LigmaSamplePoint *sp = ligma_image_get_next_sample_point (image, sample_point,
                                                              &success);

      if (sp)
        next_sample_point = ligma_aux_item_get_id (LIGMA_AUX_ITEM (sp));

      if (! success)
        g_set_error (error, LIGMA_PDB_ERROR, LIGMA_PDB_ERROR_INVALID_ARGUMENT,
                     _("Image '%s' (%d) does not contain sample point with ID %d"),
                     ligma_image_get_display_name (image),
                     ligma_image_get_id (image),
                     sample_point);
    }

  return_vals = ligma_procedure_get_return_values (procedure, success,
                                                  error ? *error : NULL);

  if (success)
    g_value_set_uint (ligma_value_array_index (return_vals, 1), next_sample_point);

  return return_vals;
}

static LigmaValueArray *
image_get_sample_point_position_invoker (LigmaProcedure         *procedure,
                                         Ligma                  *ligma,
                                         LigmaContext           *context,
                                         LigmaProgress          *progress,
                                         const LigmaValueArray  *args,
                                         GError               **error)
{
  gboolean success = TRUE;
  LigmaValueArray *return_vals;
  LigmaImage *image;
  guint sample_point;
  gint position_x = 0;
  gint position_y = 0;

  image = g_value_get_object (ligma_value_array_index (args, 0));
  sample_point = g_value_get_uint (ligma_value_array_index (args, 1));

  if (success)
    {
      LigmaSamplePoint *sp = ligma_pdb_image_get_sample_point (image, sample_point,
                                                             error);

      if (sp)
        ligma_sample_point_get_position (sp, &position_x, &position_y);
      else
        success = FALSE;
    }

  return_vals = ligma_procedure_get_return_values (procedure, success,
                                                  error ? *error : NULL);

  if (success)
    {
      g_value_set_int (ligma_value_array_index (return_vals, 1), position_x);
      g_value_set_int (ligma_value_array_index (return_vals, 2), position_y);
    }

  return return_vals;
}

void
register_image_sample_points_procs (LigmaPDB *pdb)
{
  LigmaProcedure *procedure;

  /*
   * ligma-image-add-sample-point
   */
  procedure = ligma_procedure_new (image_add_sample_point_invoker);
  ligma_object_set_static_name (LIGMA_OBJECT (procedure),
                               "ligma-image-add-sample-point");
  ligma_procedure_set_static_help (procedure,
                                  "Add a sample point to an image.",
                                  "This procedure adds a sample point to an image. It takes the input image and the position of the new sample points as parameters. It returns the sample point ID of the new sample point.",
                                  NULL);
  ligma_procedure_set_static_attribution (procedure,
                                         "Michael Natterer <mitch@ligma.org>",
                                         "Michael Natterer",
                                         "2016");
  ligma_procedure_add_argument (procedure,
                               ligma_param_spec_image ("image",
                                                      "image",
                                                      "The image",
                                                      FALSE,
                                                      LIGMA_PARAM_READWRITE));
  ligma_procedure_add_argument (procedure,
                               g_param_spec_int ("position-x",
                                                 "position x",
                                                 "The guide'sample points x-offset from left of image",
                                                 0, G_MAXINT32, 0,
                                                 LIGMA_PARAM_READWRITE));
  ligma_procedure_add_argument (procedure,
                               g_param_spec_int ("position-y",
                                                 "position y",
                                                 "The guide'sample points y-offset from top of image",
                                                 0, G_MAXINT32, 0,
                                                 LIGMA_PARAM_READWRITE));
  ligma_procedure_add_return_value (procedure,
                                   g_param_spec_uint ("sample-point",
                                                      "sample point",
                                                      "The new sample point",
                                                      1, G_MAXUINT32, 1,
                                                      LIGMA_PARAM_READWRITE));
  ligma_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * ligma-image-delete-sample-point
   */
  procedure = ligma_procedure_new (image_delete_sample_point_invoker);
  ligma_object_set_static_name (LIGMA_OBJECT (procedure),
                               "ligma-image-delete-sample-point");
  ligma_procedure_set_static_help (procedure,
                                  "Deletes a sample point from an image.",
                                  "This procedure takes an image and a sample point ID as input and removes the specified sample point from the specified image.",
                                  NULL);
  ligma_procedure_set_static_attribution (procedure,
                                         "Michael Natterer <mitch@ligma.org>",
                                         "Michael Natterer",
                                         "2016");
  ligma_procedure_add_argument (procedure,
                               ligma_param_spec_image ("image",
                                                      "image",
                                                      "The image",
                                                      FALSE,
                                                      LIGMA_PARAM_READWRITE));
  ligma_procedure_add_argument (procedure,
                               g_param_spec_uint ("sample-point",
                                                  "sample point",
                                                  "The ID of the sample point to be removed",
                                                  1, G_MAXUINT32, 1,
                                                  LIGMA_PARAM_READWRITE));
  ligma_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * ligma-image-find-next-sample-point
   */
  procedure = ligma_procedure_new (image_find_next_sample_point_invoker);
  ligma_object_set_static_name (LIGMA_OBJECT (procedure),
                               "ligma-image-find-next-sample-point");
  ligma_procedure_set_static_help (procedure,
                                  "Find next sample point on an image.",
                                  "This procedure takes an image and a sample point ID as input and finds the sample point ID of the successor of the given sample point ID in the image's sample point list. If the supplied sample point ID is 0, the procedure will return the first sample point. The procedure will return 0 if given the final sample point ID as an argument or the image has no sample points.",
                                  NULL);
  ligma_procedure_set_static_attribution (procedure,
                                         "Michael Natterer <mitch@ligma.org>",
                                         "Michael Natterer",
                                         "2016");
  ligma_procedure_add_argument (procedure,
                               ligma_param_spec_image ("image",
                                                      "image",
                                                      "The image",
                                                      FALSE,
                                                      LIGMA_PARAM_READWRITE));
  ligma_procedure_add_argument (procedure,
                               g_param_spec_uint ("sample-point",
                                                  "sample point",
                                                  "The ID of the current sample point (0 if first invocation)",
                                                  1, G_MAXUINT32, 1,
                                                  LIGMA_PARAM_READWRITE | LIGMA_PARAM_NO_VALIDATE));
  ligma_procedure_add_return_value (procedure,
                                   g_param_spec_uint ("next-sample-point",
                                                      "next sample point",
                                                      "The next sample point's ID",
                                                      1, G_MAXUINT32, 1,
                                                      LIGMA_PARAM_READWRITE));
  ligma_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * ligma-image-get-sample-point-position
   */
  procedure = ligma_procedure_new (image_get_sample_point_position_invoker);
  ligma_object_set_static_name (LIGMA_OBJECT (procedure),
                               "ligma-image-get-sample-point-position");
  ligma_procedure_set_static_help (procedure,
                                  "Get position of a sample point on an image.",
                                  "This procedure takes an image and a sample point ID as input and returns the position of the sample point relative to the top and left of the image.",
                                  NULL);
  ligma_procedure_set_static_attribution (procedure,
                                         "Michael Natterer <mitch@ligma.org>",
                                         "Michael Natterer",
                                         "2016");
  ligma_procedure_add_argument (procedure,
                               ligma_param_spec_image ("image",
                                                      "image",
                                                      "The image",
                                                      FALSE,
                                                      LIGMA_PARAM_READWRITE));
  ligma_procedure_add_argument (procedure,
                               g_param_spec_uint ("sample-point",
                                                  "sample point",
                                                  "The guide",
                                                  1, G_MAXUINT32, 1,
                                                  LIGMA_PARAM_READWRITE));
  ligma_procedure_add_return_value (procedure,
                                   g_param_spec_int ("position-x",
                                                     "position x",
                                                     "The sample points's position relative to top of image",
                                                     G_MININT32, G_MAXINT32, 0,
                                                     LIGMA_PARAM_READWRITE));
  ligma_procedure_add_return_value (procedure,
                                   g_param_spec_int ("position-y",
                                                     "position y",
                                                     "The sample points's position relative to top of image",
                                                     G_MININT32, G_MAXINT32, 0,
                                                     LIGMA_PARAM_READWRITE));
  ligma_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);
}
