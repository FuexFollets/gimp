/* LIGMA - The GNU Image Manipulation Program
 * Copyright (C) 1995-2003 Spencer Kimball and Peter Mattis
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

/* NOTE: This file is auto-generated by pdbgen.pl. */

#include "config.h"

#include "stamp-pdbgen.h"

#include <gegl.h>

#include <gdk-pixbuf/gdk-pixbuf.h>

#include "libligmaconfig/ligmaconfig.h"

#include "libligmabase/ligmabase.h"

#include "pdb-types.h"

#include "core/ligma-edit.h"
#include "core/ligma.h"
#include "core/ligmabuffer.h"
#include "core/ligmadrawable-edit.h"
#include "core/ligmadrawable.h"
#include "core/ligmaimage.h"
#include "core/ligmalayer.h"
#include "core/ligmaparamspecs.h"
#include "core/ligmaprogress.h"

#include "ligmapdb.h"
#include "ligmapdb-utils.h"
#include "ligmapdbcontext.h"
#include "ligmaprocedure.h"
#include "internal-procs.h"

#include "ligma-intl.h"


static LigmaValueArray *
edit_cut_invoker (LigmaProcedure         *procedure,
                  Ligma                  *ligma,
                  LigmaContext           *context,
                  LigmaProgress          *progress,
                  const LigmaValueArray  *args,
                  GError               **error)
{
  gboolean success = TRUE;
  LigmaValueArray *return_vals;
  gint num_drawables;
  const LigmaItem **drawables;
  gboolean non_empty = FALSE;

  num_drawables = g_value_get_int (ligma_value_array_index (args, 0));
  drawables = (const LigmaItem **) ligma_value_get_object_array (ligma_value_array_index (args, 1));

  if (success)
    {
      LigmaImage *image         = NULL;
      GList     *drawable_list = NULL;
      gint       i;

      for (i = 0; i < num_drawables; i++)
        {
          if (! ligma_pdb_item_is_attached (LIGMA_ITEM (drawables[i]), NULL,
                                           LIGMA_PDB_ITEM_CONTENT, error) ||
              ligma_pdb_item_is_group (LIGMA_ITEM (drawables[i]), error))
            {
              success = FALSE;
              break;
            }

          if (! image)
            {
              image = ligma_item_get_image (LIGMA_ITEM (drawables[i]));
            }
          else if (image != ligma_item_get_image (LIGMA_ITEM (drawables[i])))
            {
              success = FALSE;
              ligma_message_literal (ligma,
                                    G_OBJECT (progress), LIGMA_MESSAGE_WARNING,
                                    _("All specified drawables must belong to the same image."));
              break;
            }

          drawable_list = g_list_prepend (drawable_list, (gpointer) drawables[i]);
        }

      if (success && image)
        {
          GError *my_error = NULL;

          non_empty = ligma_edit_cut (image, drawable_list, context, &my_error) != NULL;

          if (! non_empty)
            {
              ligma_message_literal (ligma,
                                    G_OBJECT (progress), LIGMA_MESSAGE_WARNING,
                                    my_error->message);
              g_clear_error (&my_error);
            }
        }
      else
        {
          success = FALSE;
        }
      g_list_free (drawable_list);
    }

  return_vals = ligma_procedure_get_return_values (procedure, success,
                                                  error ? *error : NULL);

  if (success)
    g_value_set_boolean (ligma_value_array_index (return_vals, 1), non_empty);

  return return_vals;
}

static LigmaValueArray *
edit_copy_invoker (LigmaProcedure         *procedure,
                   Ligma                  *ligma,
                   LigmaContext           *context,
                   LigmaProgress          *progress,
                   const LigmaValueArray  *args,
                   GError               **error)
{
  gboolean success = TRUE;
  LigmaValueArray *return_vals;
  gint num_drawables;
  const LigmaItem **drawables;
  gboolean non_empty = FALSE;

  num_drawables = g_value_get_int (ligma_value_array_index (args, 0));
  drawables = (const LigmaItem **) ligma_value_get_object_array (ligma_value_array_index (args, 1));

  if (success)
    {
      LigmaImage *image          = NULL;
      GList     *drawables_list = NULL;
      gint       i;

      for (i = 0; i < num_drawables; i++)
        {
          if (! ligma_pdb_item_is_attached (LIGMA_ITEM (drawables[i]), NULL, 0, error))
            {
              success = FALSE;
              break;
            }
          if (image == NULL)
            {
              image = ligma_item_get_image (LIGMA_ITEM (drawables[i]));
            }
          else if (image != ligma_item_get_image (LIGMA_ITEM (drawables[i])))
            {
              success = FALSE;
              break;
            }
          drawables_list = g_list_prepend (drawables_list, (gpointer) drawables[i]);
        }

      if (success && num_drawables > 0)
        {
          GError *my_error = NULL;

          non_empty = ligma_edit_copy (image, drawables_list, context, &my_error) != NULL;

          if (! non_empty)
            {
              ligma_message_literal (ligma,
                                    G_OBJECT (progress), LIGMA_MESSAGE_WARNING,
                                    my_error->message);
              g_clear_error (&my_error);
            }
        }
      else
        success = FALSE;

      g_list_free (drawables_list);
    }

  return_vals = ligma_procedure_get_return_values (procedure, success,
                                                  error ? *error : NULL);

  if (success)
    g_value_set_boolean (ligma_value_array_index (return_vals, 1), non_empty);

  return return_vals;
}

static LigmaValueArray *
edit_copy_visible_invoker (LigmaProcedure         *procedure,
                           Ligma                  *ligma,
                           LigmaContext           *context,
                           LigmaProgress          *progress,
                           const LigmaValueArray  *args,
                           GError               **error)
{
  gboolean success = TRUE;
  LigmaValueArray *return_vals;
  LigmaImage *image;
  gboolean non_empty = FALSE;

  image = g_value_get_object (ligma_value_array_index (args, 0));

  if (success)
    {
      GError *my_error = NULL;

      non_empty = ligma_edit_copy_visible (image, context, &my_error) != NULL;

      if (! non_empty)
        {
          ligma_message_literal (ligma,
                                G_OBJECT (progress), LIGMA_MESSAGE_WARNING,
                                my_error->message);
          g_clear_error (&my_error);
        }
    }

  return_vals = ligma_procedure_get_return_values (procedure, success,
                                                  error ? *error : NULL);

  if (success)
    g_value_set_boolean (ligma_value_array_index (return_vals, 1), non_empty);

  return return_vals;
}

static LigmaValueArray *
edit_paste_invoker (LigmaProcedure         *procedure,
                    Ligma                  *ligma,
                    LigmaContext           *context,
                    LigmaProgress          *progress,
                    const LigmaValueArray  *args,
                    GError               **error)
{
  gboolean success = TRUE;
  LigmaValueArray *return_vals;
  LigmaDrawable *drawable;
  gboolean paste_into;
  gint num_layers = 0;
  LigmaLayer **layers = NULL;

  drawable = g_value_get_object (ligma_value_array_index (args, 0));
  paste_into = g_value_get_boolean (ligma_value_array_index (args, 1));

  if (success)
    {
      LigmaObject *paste = ligma_get_clipboard_object (ligma);

      if (paste &&
          ligma_pdb_item_is_attached (LIGMA_ITEM (drawable), NULL,
                                     LIGMA_PDB_ITEM_CONTENT, error) &&
          ligma_pdb_item_is_not_group (LIGMA_ITEM (drawable), error))
        {
          GList *drawables = NULL;
          GList *list;
          gint   i;

          if (drawable != NULL)
            drawables = g_list_prepend (drawables, drawable);

          list = ligma_edit_paste (ligma_item_get_image (LIGMA_ITEM (drawable)),
                                  drawables, paste,
                                  paste_into ?
                                  LIGMA_PASTE_TYPE_FLOATING_INTO :
                                  LIGMA_PASTE_TYPE_FLOATING,
                                  context, FALSE,
                                  -1, -1, -1, -1);
          g_list_free (drawables);

          if (! list)
            success = FALSE;

          num_layers = g_list_length (list);
          layers = g_new (LigmaLayer *, num_layers);

          for (i = 0; i < num_layers; i++, list = g_list_next (list))
            layers[i] = g_object_ref (list->data);

          g_list_free (list);
        }
      else
        success = FALSE;
    }

  return_vals = ligma_procedure_get_return_values (procedure, success,
                                                  error ? *error : NULL);

  if (success)
    {
      g_value_set_int (ligma_value_array_index (return_vals, 1), num_layers);
      ligma_value_take_object_array (ligma_value_array_index (return_vals, 2), LIGMA_TYPE_LAYER, (GObject **) layers, num_layers);
    }

  return return_vals;
}

static LigmaValueArray *
edit_paste_as_new_image_invoker (LigmaProcedure         *procedure,
                                 Ligma                  *ligma,
                                 LigmaContext           *context,
                                 LigmaProgress          *progress,
                                 const LigmaValueArray  *args,
                                 GError               **error)
{
  gboolean success = TRUE;
  LigmaValueArray *return_vals;
  LigmaImage *image = NULL;

  LigmaObject *paste = ligma_get_clipboard_object (ligma);

  if (paste)
    {
      image = ligma_edit_paste_as_new_image (ligma, paste);

      if (! image)
        success = FALSE;
    }

  return_vals = ligma_procedure_get_return_values (procedure, success,
                                                  error ? *error : NULL);

  if (success)
    g_value_set_object (ligma_value_array_index (return_vals, 1), image);

  return return_vals;
}

static LigmaValueArray *
edit_named_cut_invoker (LigmaProcedure         *procedure,
                        Ligma                  *ligma,
                        LigmaContext           *context,
                        LigmaProgress          *progress,
                        const LigmaValueArray  *args,
                        GError               **error)
{
  gboolean success = TRUE;
  LigmaValueArray *return_vals;
  gint num_drawables;
  const LigmaItem **drawables;
  const gchar *buffer_name;
  gchar *real_name = NULL;

  num_drawables = g_value_get_int (ligma_value_array_index (args, 0));
  drawables = (const LigmaItem **) ligma_value_get_object_array (ligma_value_array_index (args, 1));
  buffer_name = g_value_get_string (ligma_value_array_index (args, 2));

  if (success)
    {
      LigmaImage *image         = NULL;
      GList     *drawable_list = NULL;
      gint       i;

      for (i = 0; i < num_drawables; i++)
        {
          if (! ligma_pdb_item_is_attached (LIGMA_ITEM (drawables[i]), NULL,
                                           LIGMA_PDB_ITEM_CONTENT, error) ||
              ligma_pdb_item_is_group (LIGMA_ITEM (drawables[i]), error))
            {
              success = FALSE;
              break;
            }

          if (! image)
            {
              image = ligma_item_get_image (LIGMA_ITEM (drawables[i]));
            }
          else if (image != ligma_item_get_image (LIGMA_ITEM (drawables[i])))
            {
              success = FALSE;
              ligma_message_literal (ligma,
                                    G_OBJECT (progress), LIGMA_MESSAGE_WARNING,
                                    _("All specified drawables must belong to the same image."));
              break;
            }

          drawable_list = g_list_prepend (drawable_list, (gpointer) drawables[i]);
        }

      if (success && image)
        {
          GError *my_error = NULL;

          real_name = (gchar *) ligma_edit_named_cut (image, buffer_name,
                                                     drawable_list, context, &my_error);

          if (real_name)
            {
              real_name = g_strdup (real_name);
            }
          else
            {
              ligma_message_literal (ligma,
                                    G_OBJECT (progress), LIGMA_MESSAGE_WARNING,
                                    my_error->message);
              g_clear_error (&my_error);
            }
        }
      else
        {
          success = FALSE;
        }
      g_list_free (drawable_list);
    }

  return_vals = ligma_procedure_get_return_values (procedure, success,
                                                  error ? *error : NULL);

  if (success)
    g_value_take_string (ligma_value_array_index (return_vals, 1), real_name);

  return return_vals;
}

static LigmaValueArray *
edit_named_copy_invoker (LigmaProcedure         *procedure,
                         Ligma                  *ligma,
                         LigmaContext           *context,
                         LigmaProgress          *progress,
                         const LigmaValueArray  *args,
                         GError               **error)
{
  gboolean success = TRUE;
  LigmaValueArray *return_vals;
  gint num_drawables;
  const LigmaItem **drawables;
  const gchar *buffer_name;
  gchar *real_name = NULL;

  num_drawables = g_value_get_int (ligma_value_array_index (args, 0));
  drawables = (const LigmaItem **) ligma_value_get_object_array (ligma_value_array_index (args, 1));
  buffer_name = g_value_get_string (ligma_value_array_index (args, 2));

  if (success)
    {
      LigmaImage *image         = NULL;
      GList     *drawable_list = NULL;
      gint       i;

      for (i = 0; i < num_drawables; i++)
        {
          if (! ligma_pdb_item_is_attached (LIGMA_ITEM (drawables[i]), NULL,
                                           0, error))
            {
              success = FALSE;
              break;
            }

          if (! image)
            {
              image = ligma_item_get_image (LIGMA_ITEM (drawables[i]));
            }
          else if (image != ligma_item_get_image (LIGMA_ITEM (drawables[i])))
            {
              success = FALSE;
              ligma_message_literal (ligma,
                                    G_OBJECT (progress), LIGMA_MESSAGE_WARNING,
                                    _("All specified drawables must belong to the same image."));
              break;
            }

          drawable_list = g_list_prepend (drawable_list, (gpointer) drawables[i]);
        }

      if (success && image)
        {
          GError *my_error = NULL;

          real_name = (gchar *) ligma_edit_named_copy (image, buffer_name,
                                                      drawable_list, context, &my_error);

          if (real_name)
            {
              real_name = g_strdup (real_name);
            }
          else
            {
              ligma_message_literal (ligma,
                                    G_OBJECT (progress), LIGMA_MESSAGE_WARNING,
                                    my_error->message);
              g_clear_error (&my_error);
            }
        }
      else
        {
          success = FALSE;
        }
      g_list_free (drawable_list);
    }

  return_vals = ligma_procedure_get_return_values (procedure, success,
                                                  error ? *error : NULL);

  if (success)
    g_value_take_string (ligma_value_array_index (return_vals, 1), real_name);

  return return_vals;
}

static LigmaValueArray *
edit_named_copy_visible_invoker (LigmaProcedure         *procedure,
                                 Ligma                  *ligma,
                                 LigmaContext           *context,
                                 LigmaProgress          *progress,
                                 const LigmaValueArray  *args,
                                 GError               **error)
{
  gboolean success = TRUE;
  LigmaValueArray *return_vals;
  LigmaImage *image;
  const gchar *buffer_name;
  gchar *real_name = NULL;

  image = g_value_get_object (ligma_value_array_index (args, 0));
  buffer_name = g_value_get_string (ligma_value_array_index (args, 1));

  if (success)
    {
      GError *my_error = NULL;

      real_name = (gchar *) ligma_edit_named_copy_visible (image, buffer_name,
                                                          context, &my_error);

      if (real_name)
        {
          real_name = g_strdup (real_name);
        }
      else
        {
          ligma_message_literal (ligma,
                                G_OBJECT (progress), LIGMA_MESSAGE_WARNING,
                                my_error->message);
          g_clear_error (&my_error);
        }
    }

  return_vals = ligma_procedure_get_return_values (procedure, success,
                                                  error ? *error : NULL);

  if (success)
    g_value_take_string (ligma_value_array_index (return_vals, 1), real_name);

  return return_vals;
}

static LigmaValueArray *
edit_named_paste_invoker (LigmaProcedure         *procedure,
                          Ligma                  *ligma,
                          LigmaContext           *context,
                          LigmaProgress          *progress,
                          const LigmaValueArray  *args,
                          GError               **error)
{
  gboolean success = TRUE;
  LigmaValueArray *return_vals;
  LigmaDrawable *drawable;
  const gchar *buffer_name;
  gboolean paste_into;
  LigmaLayer *floating_sel = NULL;

  drawable = g_value_get_object (ligma_value_array_index (args, 0));
  buffer_name = g_value_get_string (ligma_value_array_index (args, 1));
  paste_into = g_value_get_boolean (ligma_value_array_index (args, 2));

  if (success)
    {
      LigmaBuffer *buffer = ligma_pdb_get_buffer (ligma, buffer_name, error);

      if (buffer &&
          ligma_pdb_item_is_attached (LIGMA_ITEM (drawable), NULL,
                                     LIGMA_PDB_ITEM_CONTENT, error) &&
          ligma_pdb_item_is_not_group (LIGMA_ITEM (drawable), error))
        {
          GList *drawables = NULL;
          GList *layers;

          if (drawable != NULL)
            drawables = g_list_prepend (drawables, drawable);

          layers = ligma_edit_paste (ligma_item_get_image (LIGMA_ITEM (drawable)),
                                    drawables, LIGMA_OBJECT (buffer),
                                    paste_into ?
                                    LIGMA_PASTE_TYPE_FLOATING_INTO :
                                    LIGMA_PASTE_TYPE_FLOATING,
                                    context, FALSE,
                                    -1, -1, -1, -1);
          g_list_free (drawables);

          if (! layers)
            success = FALSE;
          else
            floating_sel = layers->data;

          g_list_free (layers);
        }
      else
        success = FALSE;
    }

  return_vals = ligma_procedure_get_return_values (procedure, success,
                                                  error ? *error : NULL);

  if (success)
    g_value_set_object (ligma_value_array_index (return_vals, 1), floating_sel);

  return return_vals;
}

static LigmaValueArray *
edit_named_paste_as_new_image_invoker (LigmaProcedure         *procedure,
                                       Ligma                  *ligma,
                                       LigmaContext           *context,
                                       LigmaProgress          *progress,
                                       const LigmaValueArray  *args,
                                       GError               **error)
{
  gboolean success = TRUE;
  LigmaValueArray *return_vals;
  const gchar *buffer_name;
  LigmaImage *image = NULL;

  buffer_name = g_value_get_string (ligma_value_array_index (args, 0));

  if (success)
    {
      LigmaBuffer *buffer = ligma_pdb_get_buffer (ligma, buffer_name, error);

      if (buffer)
        {
          image = ligma_edit_paste_as_new_image (ligma, LIGMA_OBJECT (buffer));

          if (! image)
            success = FALSE;
        }
      else
        success = FALSE;
    }

  return_vals = ligma_procedure_get_return_values (procedure, success,
                                                  error ? *error : NULL);

  if (success)
    g_value_set_object (ligma_value_array_index (return_vals, 1), image);

  return return_vals;
}

void
register_edit_procs (LigmaPDB *pdb)
{
  LigmaProcedure *procedure;

  /*
   * ligma-edit-cut
   */
  procedure = ligma_procedure_new (edit_cut_invoker);
  ligma_object_set_static_name (LIGMA_OBJECT (procedure),
                               "ligma-edit-cut");
  ligma_procedure_set_static_help (procedure,
                                  "Cut from the specified drawables.",
                                  "If there is a selection in the image, then the area specified by the selection is cut from the specified drawables and placed in an internal LIGMA edit buffer. It can subsequently be retrieved using the 'ligma-edit-paste' command. If there is no selection and only one specified drawable, then the specified drawable will be removed and its contents stored in the internal LIGMA edit buffer. This procedure will fail if the selected area lies completely outside the bounds of the current drawables and there is nothing to cut from.",
                                  NULL);
  ligma_procedure_set_static_attribution (procedure,
                                         "Spencer Kimball & Peter Mattis",
                                         "Spencer Kimball & Peter Mattis",
                                         "1995-1996");
  ligma_procedure_add_argument (procedure,
                               g_param_spec_int ("num-drawables",
                                                 "num drawables",
                                                 "The number of drawables",
                                                 1, G_MAXINT32, 1,
                                                 LIGMA_PARAM_READWRITE));
  ligma_procedure_add_argument (procedure,
                               ligma_param_spec_object_array ("drawables",
                                                             "drawables",
                                                             "The drawables to cut from",
                                                             LIGMA_TYPE_ITEM,
                                                             LIGMA_PARAM_READWRITE | LIGMA_PARAM_NO_VALIDATE));
  ligma_procedure_add_return_value (procedure,
                                   g_param_spec_boolean ("non-empty",
                                                         "non empty",
                                                         "TRUE if the cut was successful, FALSE if there was nothing to copy from",
                                                         FALSE,
                                                         LIGMA_PARAM_READWRITE));
  ligma_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * ligma-edit-copy
   */
  procedure = ligma_procedure_new (edit_copy_invoker);
  ligma_object_set_static_name (LIGMA_OBJECT (procedure),
                               "ligma-edit-copy");
  ligma_procedure_set_static_help (procedure,
                                  "Copy from the specified drawables.",
                                  "If there is a selection in the image, then the area specified by the selection is copied from the specified drawables and placed in an internal LIGMA edit buffer. It can subsequently be retrieved using the 'ligma-edit-paste' command. If there is no selection, then the specified drawables' contents will be stored in the internal LIGMA edit buffer. This procedure will fail if the selected area lies completely outside the bounds of the current drawables and there is nothing to copy from. All the drawables must belong to the same image.",
                                  NULL);
  ligma_procedure_set_static_attribution (procedure,
                                         "Spencer Kimball & Peter Mattis",
                                         "Spencer Kimball & Peter Mattis",
                                         "1995-1996");
  ligma_procedure_add_argument (procedure,
                               g_param_spec_int ("num-drawables",
                                                 "num drawables",
                                                 "The number of drawables to save",
                                                 1, G_MAXINT32, 1,
                                                 LIGMA_PARAM_READWRITE));
  ligma_procedure_add_argument (procedure,
                               ligma_param_spec_object_array ("drawables",
                                                             "drawables",
                                                             "Drawables to copy from",
                                                             LIGMA_TYPE_ITEM,
                                                             LIGMA_PARAM_READWRITE | LIGMA_PARAM_NO_VALIDATE));
  ligma_procedure_add_return_value (procedure,
                                   g_param_spec_boolean ("non-empty",
                                                         "non empty",
                                                         "TRUE if the cut was successful, FALSE if there was nothing to copy from",
                                                         FALSE,
                                                         LIGMA_PARAM_READWRITE));
  ligma_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * ligma-edit-copy-visible
   */
  procedure = ligma_procedure_new (edit_copy_visible_invoker);
  ligma_object_set_static_name (LIGMA_OBJECT (procedure),
                               "ligma-edit-copy-visible");
  ligma_procedure_set_static_help (procedure,
                                  "Copy from the projection.",
                                  "If there is a selection in the image, then the area specified by the selection is copied from the projection and placed in an internal LIGMA edit buffer. It can subsequently be retrieved using the 'ligma-edit-paste' command. If there is no selection, then the projection's contents will be stored in the internal LIGMA edit buffer.",
                                  NULL);
  ligma_procedure_set_static_attribution (procedure,
                                         "Michael Natterer <mitch@ligma.org>",
                                         "Michael Natterer",
                                         "2004");
  ligma_procedure_add_argument (procedure,
                               ligma_param_spec_image ("image",
                                                      "image",
                                                      "The image to copy from",
                                                      FALSE,
                                                      LIGMA_PARAM_READWRITE));
  ligma_procedure_add_return_value (procedure,
                                   g_param_spec_boolean ("non-empty",
                                                         "non empty",
                                                         "TRUE if the copy was successful",
                                                         FALSE,
                                                         LIGMA_PARAM_READWRITE));
  ligma_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * ligma-edit-paste
   */
  procedure = ligma_procedure_new (edit_paste_invoker);
  ligma_object_set_static_name (LIGMA_OBJECT (procedure),
                               "ligma-edit-paste");
  ligma_procedure_set_static_help (procedure,
                                  "Paste buffer to the specified drawable.",
                                  "This procedure pastes a copy of the internal LIGMA edit buffer to the specified drawable. The LIGMA edit buffer will be empty unless a call was previously made to either 'ligma-edit-cut' or 'ligma-edit-copy'. The \"paste_into\" option specifies whether to clear the current image selection, or to paste the buffer \"behind\" the selection. This allows the selection to act as a mask for the pasted buffer. Anywhere that the selection mask is non-zero, the pasted buffer will show through. The pasted data may be a floating selection when relevant, layers otherwise. If the image has a floating selection at the time of pasting, the old floating selection will be anchored to its drawable before the new floating selection is added.\n"
                                  "This procedure returns the new layers (floating or not). If the result is a floating selection, it will already be attached to the specified drawable, and a subsequent call to floating_sel_attach is not needed.",
                                  NULL);
  ligma_procedure_set_static_attribution (procedure,
                                         "Spencer Kimball & Peter Mattis",
                                         "Spencer Kimball & Peter Mattis",
                                         "1995-1996");
  ligma_procedure_add_argument (procedure,
                               ligma_param_spec_drawable ("drawable",
                                                         "drawable",
                                                         "The drawable to paste to",
                                                         FALSE,
                                                         LIGMA_PARAM_READWRITE));
  ligma_procedure_add_argument (procedure,
                               g_param_spec_boolean ("paste-into",
                                                     "paste into",
                                                     "Clear selection, or paste behind it?",
                                                     FALSE,
                                                     LIGMA_PARAM_READWRITE));
  ligma_procedure_add_return_value (procedure,
                                   g_param_spec_int ("num-layers",
                                                     "num layers",
                                                     "The newly pasted layers",
                                                     0, G_MAXINT32, 0,
                                                     LIGMA_PARAM_READWRITE));
  ligma_procedure_add_return_value (procedure,
                                   ligma_param_spec_object_array ("layers",
                                                                 "layers",
                                                                 "The list of pasted layers.",
                                                                 LIGMA_TYPE_LAYER,
                                                                 LIGMA_PARAM_READWRITE));
  ligma_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * ligma-edit-paste-as-new-image
   */
  procedure = ligma_procedure_new (edit_paste_as_new_image_invoker);
  ligma_object_set_static_name (LIGMA_OBJECT (procedure),
                               "ligma-edit-paste-as-new-image");
  ligma_procedure_set_static_help (procedure,
                                  "Paste buffer to a new image.",
                                  "This procedure pastes a copy of the internal LIGMA edit buffer to a new image. The LIGMA edit buffer will be empty unless a call was previously made to either 'ligma-edit-cut' or 'ligma-edit-copy'. This procedure returns the new image or -1 if the edit buffer was empty.",
                                  NULL);
  ligma_procedure_set_static_attribution (procedure,
                                         "Michael Natterer <mitch@ligma.org>",
                                         "Michael Natterer",
                                         "2005");
  ligma_procedure_add_return_value (procedure,
                                   ligma_param_spec_image ("image",
                                                          "image",
                                                          "The new image",
                                                          FALSE,
                                                          LIGMA_PARAM_READWRITE));
  ligma_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * ligma-edit-named-cut
   */
  procedure = ligma_procedure_new (edit_named_cut_invoker);
  ligma_object_set_static_name (LIGMA_OBJECT (procedure),
                               "ligma-edit-named-cut");
  ligma_procedure_set_static_help (procedure,
                                  "Cut into a named buffer.",
                                  "This procedure works like 'ligma-edit-cut', but additionally stores the cut buffer into a named buffer that will stay available for later pasting, regardless of any intermediate copy or cut operations.",
                                  NULL);
  ligma_procedure_set_static_attribution (procedure,
                                         "Michael Natterer <mitch@ligma.org>",
                                         "Michael Natterer",
                                         "2005");
  ligma_procedure_add_argument (procedure,
                               g_param_spec_int ("num-drawables",
                                                 "num drawables",
                                                 "The number of drawables",
                                                 1, G_MAXINT32, 1,
                                                 LIGMA_PARAM_READWRITE));
  ligma_procedure_add_argument (procedure,
                               ligma_param_spec_object_array ("drawables",
                                                             "drawables",
                                                             "The drawables to cut from",
                                                             LIGMA_TYPE_ITEM,
                                                             LIGMA_PARAM_READWRITE | LIGMA_PARAM_NO_VALIDATE));
  ligma_procedure_add_argument (procedure,
                               ligma_param_spec_string ("buffer-name",
                                                       "buffer name",
                                                       "The name of the buffer to create",
                                                       FALSE, FALSE, TRUE,
                                                       NULL,
                                                       LIGMA_PARAM_READWRITE));
  ligma_procedure_add_return_value (procedure,
                                   ligma_param_spec_string ("real-name",
                                                           "real name",
                                                           "The real name given to the buffer, or NULL if the cut failed",
                                                           FALSE, FALSE, FALSE,
                                                           NULL,
                                                           LIGMA_PARAM_READWRITE));
  ligma_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * ligma-edit-named-copy
   */
  procedure = ligma_procedure_new (edit_named_copy_invoker);
  ligma_object_set_static_name (LIGMA_OBJECT (procedure),
                               "ligma-edit-named-copy");
  ligma_procedure_set_static_help (procedure,
                                  "Copy into a named buffer.",
                                  "This procedure works like 'ligma-edit-copy', but additionally stores the copied buffer into a named buffer that will stay available for later pasting, regardless of any intermediate copy or cut operations.",
                                  NULL);
  ligma_procedure_set_static_attribution (procedure,
                                         "Michael Natterer <mitch@ligma.org>",
                                         "Michael Natterer",
                                         "2005");
  ligma_procedure_add_argument (procedure,
                               g_param_spec_int ("num-drawables",
                                                 "num drawables",
                                                 "The number of drawables",
                                                 1, G_MAXINT32, 1,
                                                 LIGMA_PARAM_READWRITE));
  ligma_procedure_add_argument (procedure,
                               ligma_param_spec_object_array ("drawables",
                                                             "drawables",
                                                             "The drawables to copy from",
                                                             LIGMA_TYPE_ITEM,
                                                             LIGMA_PARAM_READWRITE | LIGMA_PARAM_NO_VALIDATE));
  ligma_procedure_add_argument (procedure,
                               ligma_param_spec_string ("buffer-name",
                                                       "buffer name",
                                                       "The name of the buffer to create",
                                                       FALSE, FALSE, TRUE,
                                                       NULL,
                                                       LIGMA_PARAM_READWRITE));
  ligma_procedure_add_return_value (procedure,
                                   ligma_param_spec_string ("real-name",
                                                           "real name",
                                                           "The real name given to the buffer, or NULL if the copy failed",
                                                           FALSE, FALSE, FALSE,
                                                           NULL,
                                                           LIGMA_PARAM_READWRITE));
  ligma_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * ligma-edit-named-copy-visible
   */
  procedure = ligma_procedure_new (edit_named_copy_visible_invoker);
  ligma_object_set_static_name (LIGMA_OBJECT (procedure),
                               "ligma-edit-named-copy-visible");
  ligma_procedure_set_static_help (procedure,
                                  "Copy from the projection into a named buffer.",
                                  "This procedure works like 'ligma-edit-copy-visible', but additionally stores the copied buffer into a named buffer that will stay available for later pasting, regardless of any intermediate copy or cut operations.",
                                  NULL);
  ligma_procedure_set_static_attribution (procedure,
                                         "Michael Natterer <mitch@ligma.org>",
                                         "Michael Natterer",
                                         "2005");
  ligma_procedure_add_argument (procedure,
                               ligma_param_spec_image ("image",
                                                      "image",
                                                      "The image to copy from",
                                                      FALSE,
                                                      LIGMA_PARAM_READWRITE));
  ligma_procedure_add_argument (procedure,
                               ligma_param_spec_string ("buffer-name",
                                                       "buffer name",
                                                       "The name of the buffer to create",
                                                       FALSE, FALSE, TRUE,
                                                       NULL,
                                                       LIGMA_PARAM_READWRITE));
  ligma_procedure_add_return_value (procedure,
                                   ligma_param_spec_string ("real-name",
                                                           "real name",
                                                           "The real name given to the buffer, or NULL if the copy failed",
                                                           FALSE, FALSE, FALSE,
                                                           NULL,
                                                           LIGMA_PARAM_READWRITE));
  ligma_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * ligma-edit-named-paste
   */
  procedure = ligma_procedure_new (edit_named_paste_invoker);
  ligma_object_set_static_name (LIGMA_OBJECT (procedure),
                               "ligma-edit-named-paste");
  ligma_procedure_set_static_help (procedure,
                                  "Paste named buffer to the specified drawable.",
                                  "This procedure works like 'ligma-edit-paste' but pastes a named buffer instead of the global buffer.",
                                  NULL);
  ligma_procedure_set_static_attribution (procedure,
                                         "Michael Natterer <mitch@ligma.org>",
                                         "Michael Natterer",
                                         "2005");
  ligma_procedure_add_argument (procedure,
                               ligma_param_spec_drawable ("drawable",
                                                         "drawable",
                                                         "The drawable to paste to",
                                                         FALSE,
                                                         LIGMA_PARAM_READWRITE));
  ligma_procedure_add_argument (procedure,
                               ligma_param_spec_string ("buffer-name",
                                                       "buffer name",
                                                       "The name of the buffer to paste",
                                                       FALSE, FALSE, FALSE,
                                                       NULL,
                                                       LIGMA_PARAM_READWRITE));
  ligma_procedure_add_argument (procedure,
                               g_param_spec_boolean ("paste-into",
                                                     "paste into",
                                                     "Clear selection, or paste behind it?",
                                                     FALSE,
                                                     LIGMA_PARAM_READWRITE));
  ligma_procedure_add_return_value (procedure,
                                   ligma_param_spec_layer ("floating-sel",
                                                          "floating sel",
                                                          "The new floating selection",
                                                          FALSE,
                                                          LIGMA_PARAM_READWRITE));
  ligma_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * ligma-edit-named-paste-as-new-image
   */
  procedure = ligma_procedure_new (edit_named_paste_as_new_image_invoker);
  ligma_object_set_static_name (LIGMA_OBJECT (procedure),
                               "ligma-edit-named-paste-as-new-image");
  ligma_procedure_set_static_help (procedure,
                                  "Paste named buffer to a new image.",
                                  "This procedure works like 'ligma-edit-paste-as-new-image' but pastes a named buffer instead of the global buffer.",
                                  NULL);
  ligma_procedure_set_static_attribution (procedure,
                                         "Michael Natterer <mitch@ligma.org>",
                                         "Michael Natterer",
                                         "2005");
  ligma_procedure_add_argument (procedure,
                               ligma_param_spec_string ("buffer-name",
                                                       "buffer name",
                                                       "The name of the buffer to paste",
                                                       FALSE, FALSE, FALSE,
                                                       NULL,
                                                       LIGMA_PARAM_READWRITE));
  ligma_procedure_add_return_value (procedure,
                                   ligma_param_spec_image ("image",
                                                          "image",
                                                          "The new image",
                                                          FALSE,
                                                          LIGMA_PARAM_READWRITE));
  ligma_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);
}
