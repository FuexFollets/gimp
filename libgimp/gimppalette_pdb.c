/* LIBLIGMA - The LIGMA Library
 * Copyright (C) 1995-2003 Peter Mattis and Spencer Kimball
 *
 * ligmapalette_pdb.c
 *
 * This library is free software: you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library.  If not, see
 * <https://www.gnu.org/licenses/>.
 */

/* NOTE: This file is auto-generated by pdbgen.pl */

#include "config.h"

#include "stamp-pdbgen.h"

#include "ligma.h"


/**
 * SECTION: ligmapalette
 * @title: ligmapalette
 * @short_description: Functions operating on a single palette.
 *
 * Functions operating on a single palette.
 **/


/**
 * ligma_palette_new:
 * @name: The requested name of the new palette.
 *
 * Creates a new palette
 *
 * This procedure creates a new, uninitialized palette
 *
 * Returns: (transfer full): The actual new palette name.
 *          The returned value must be freed with g_free().
 *
 * Since: 2.2
 **/
gchar *
ligma_palette_new (const gchar *name)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gchar *actual_name = NULL;

  args = ligma_value_array_new_from_types (NULL,
                                          G_TYPE_STRING, name,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-palette-new",
                                              args);
  ligma_value_array_unref (args);

  if (LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS)
    actual_name = LIGMA_VALUES_DUP_STRING (return_vals, 1);

  ligma_value_array_unref (return_vals);

  return actual_name;
}

/**
 * ligma_palette_duplicate:
 * @name: The palette name.
 *
 * Duplicates a palette
 *
 * This procedure creates an identical palette by a different name
 *
 * Returns: (transfer full): The name of the palette's copy.
 *          The returned value must be freed with g_free().
 *
 * Since: 2.2
 **/
gchar *
ligma_palette_duplicate (const gchar *name)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gchar *copy_name = NULL;

  args = ligma_value_array_new_from_types (NULL,
                                          G_TYPE_STRING, name,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-palette-duplicate",
                                              args);
  ligma_value_array_unref (args);

  if (LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS)
    copy_name = LIGMA_VALUES_DUP_STRING (return_vals, 1);

  ligma_value_array_unref (return_vals);

  return copy_name;
}

/**
 * ligma_palette_rename:
 * @name: The palette name.
 * @new_name: The new name of the palette.
 *
 * Rename a palette
 *
 * This procedure renames a palette
 *
 * Returns: (transfer full): The actual new name of the palette.
 *          The returned value must be freed with g_free().
 *
 * Since: 2.2
 **/
gchar *
ligma_palette_rename (const gchar *name,
                     const gchar *new_name)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gchar *actual_name = NULL;

  args = ligma_value_array_new_from_types (NULL,
                                          G_TYPE_STRING, name,
                                          G_TYPE_STRING, new_name,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-palette-rename",
                                              args);
  ligma_value_array_unref (args);

  if (LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS)
    actual_name = LIGMA_VALUES_DUP_STRING (return_vals, 1);

  ligma_value_array_unref (return_vals);

  return actual_name;
}

/**
 * ligma_palette_delete:
 * @name: The palette name.
 *
 * Deletes a palette
 *
 * This procedure deletes a palette
 *
 * Returns: TRUE on success.
 *
 * Since: 2.2
 **/
gboolean
ligma_palette_delete (const gchar *name)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gboolean success = TRUE;

  args = ligma_value_array_new_from_types (NULL,
                                          G_TYPE_STRING, name,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-palette-delete",
                                              args);
  ligma_value_array_unref (args);

  success = LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS;

  ligma_value_array_unref (return_vals);

  return success;
}

/**
 * ligma_palette_is_editable:
 * @name: The palette name.
 *
 * Tests if palette can be edited
 *
 * Returns TRUE if you have permission to change the palette
 *
 * Returns: TRUE if the palette can be edited.
 *
 * Since: 2.4
 **/
gboolean
ligma_palette_is_editable (const gchar *name)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gboolean editable = FALSE;

  args = ligma_value_array_new_from_types (NULL,
                                          G_TYPE_STRING, name,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-palette-is-editable",
                                              args);
  ligma_value_array_unref (args);

  if (LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS)
    editable = LIGMA_VALUES_GET_BOOLEAN (return_vals, 1);

  ligma_value_array_unref (return_vals);

  return editable;
}

/**
 * ligma_palette_get_info:
 * @name: The palette name.
 * @num_colors: (out): The number of colors in the palette.
 *
 * Retrieve information about the specified palette.
 *
 * This procedure retrieves information about the specified palette.
 * This includes the name, and the number of colors.
 *
 * Returns: TRUE on success.
 *
 * Since: 2.2
 **/
gboolean
ligma_palette_get_info (const gchar *name,
                       gint        *num_colors)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gboolean success = TRUE;

  args = ligma_value_array_new_from_types (NULL,
                                          G_TYPE_STRING, name,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-palette-get-info",
                                              args);
  ligma_value_array_unref (args);

  *num_colors = 0;

  success = LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS;

  if (success)
    *num_colors = LIGMA_VALUES_GET_INT (return_vals, 1);

  ligma_value_array_unref (return_vals);

  return success;
}

/**
 * ligma_palette_get_colors:
 * @name: The palette name.
 * @num_colors: (out): Length of the colors array.
 *
 * Gets all colors from the specified palette.
 *
 * This procedure retrieves all color entries of the specified palette.
 *
 * Returns: (array length=num_colors) (element-type LigmaRGB) (transfer full):
 *          The colors in the palette.
 *          The returned value must be freed with g_free().
 *
 * Since: 2.6
 **/
LigmaRGB *
ligma_palette_get_colors (const gchar *name,
                         gint        *num_colors)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  LigmaRGB *colors = NULL;

  args = ligma_value_array_new_from_types (NULL,
                                          G_TYPE_STRING, name,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-palette-get-colors",
                                              args);
  ligma_value_array_unref (args);

  *num_colors = 0;

  if (LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS)
    {
      *num_colors = LIGMA_VALUES_GET_INT (return_vals, 1);
      colors = LIGMA_VALUES_DUP_RGB_ARRAY (return_vals, 2);
    }

  ligma_value_array_unref (return_vals);

  return colors;
}

/**
 * ligma_palette_get_columns:
 * @name: The palette name.
 *
 * Retrieves the number of columns to use to display this palette
 *
 * This procedures retrieves the preferred number of columns to use
 * when the palette is being displayed.
 *
 * Returns: The number of columns used to display this palette.
 *
 * Since: 2.4
 **/
gint
ligma_palette_get_columns (const gchar *name)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gint num_columns = 0;

  args = ligma_value_array_new_from_types (NULL,
                                          G_TYPE_STRING, name,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-palette-get-columns",
                                              args);
  ligma_value_array_unref (args);

  if (LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS)
    num_columns = LIGMA_VALUES_GET_INT (return_vals, 1);

  ligma_value_array_unref (return_vals);

  return num_columns;
}

/**
 * ligma_palette_set_columns:
 * @name: The palette name.
 * @columns: The new number of columns.
 *
 * Sets the number of columns to use when displaying the palette
 *
 * This procedures controls how many colors are shown per row when the
 * palette is being displayed. This value can only be changed if the
 * palette is writable. The maximum allowed value is 64.
 *
 * Returns: TRUE on success.
 *
 * Since: 2.4
 **/
gboolean
ligma_palette_set_columns (const gchar *name,
                          gint         columns)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gboolean success = TRUE;

  args = ligma_value_array_new_from_types (NULL,
                                          G_TYPE_STRING, name,
                                          G_TYPE_INT, columns,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-palette-set-columns",
                                              args);
  ligma_value_array_unref (args);

  success = LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS;

  ligma_value_array_unref (return_vals);

  return success;
}

/**
 * ligma_palette_add_entry:
 * @name: The palette name.
 * @entry_name: The name of the entry.
 * @color: The new entry's color color.
 * @entry_num: (out): The index of the added entry.
 *
 * Adds a palette entry to the specified palette.
 *
 * This procedure adds an entry to the specified palette. It returns an
 * error if the entry palette does not exist.
 *
 * Returns: TRUE on success.
 *
 * Since: 2.2
 **/
gboolean
ligma_palette_add_entry (const gchar   *name,
                        const gchar   *entry_name,
                        const LigmaRGB *color,
                        gint          *entry_num)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gboolean success = TRUE;

  args = ligma_value_array_new_from_types (NULL,
                                          G_TYPE_STRING, name,
                                          G_TYPE_STRING, entry_name,
                                          LIGMA_TYPE_RGB, color,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-palette-add-entry",
                                              args);
  ligma_value_array_unref (args);

  *entry_num = 0;

  success = LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS;

  if (success)
    *entry_num = LIGMA_VALUES_GET_INT (return_vals, 1);

  ligma_value_array_unref (return_vals);

  return success;
}

/**
 * ligma_palette_delete_entry:
 * @name: The palette name.
 * @entry_num: The index of the added entry.
 *
 * Deletes a palette entry from the specified palette.
 *
 * This procedure deletes an entry from the specified palette. It
 * returns an error if the entry palette does not exist.
 *
 * Returns: TRUE on success.
 *
 * Since: 2.2
 **/
gboolean
ligma_palette_delete_entry (const gchar *name,
                           gint         entry_num)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gboolean success = TRUE;

  args = ligma_value_array_new_from_types (NULL,
                                          G_TYPE_STRING, name,
                                          G_TYPE_INT, entry_num,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-palette-delete-entry",
                                              args);
  ligma_value_array_unref (args);

  success = LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS;

  ligma_value_array_unref (return_vals);

  return success;
}

/**
 * ligma_palette_entry_get_color:
 * @name: The palette name.
 * @entry_num: The entry to retrieve.
 * @color: (out caller-allocates): The color requested.
 *
 * Gets the specified palette entry from the specified palette.
 *
 * This procedure retrieves the color of the zero-based entry specified
 * for the specified palette. It returns an error if the entry does not
 * exist.
 *
 * Returns: TRUE on success.
 *
 * Since: 2.2
 **/
gboolean
ligma_palette_entry_get_color (const gchar *name,
                              gint         entry_num,
                              LigmaRGB     *color)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gboolean success = TRUE;

  args = ligma_value_array_new_from_types (NULL,
                                          G_TYPE_STRING, name,
                                          G_TYPE_INT, entry_num,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-palette-entry-get-color",
                                              args);
  ligma_value_array_unref (args);

  success = LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS;

  if (success)
    LIGMA_VALUES_GET_RGB (return_vals, 1, &*color);

  ligma_value_array_unref (return_vals);

  return success;
}

/**
 * ligma_palette_entry_set_color:
 * @name: The palette name.
 * @entry_num: The entry to retrieve.
 * @color: The new color.
 *
 * Sets the specified palette entry in the specified palette.
 *
 * This procedure sets the color of the zero-based entry specified for
 * the specified palette. It returns an error if the entry does not
 * exist.
 *
 * Returns: TRUE on success.
 *
 * Since: 2.2
 **/
gboolean
ligma_palette_entry_set_color (const gchar   *name,
                              gint           entry_num,
                              const LigmaRGB *color)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gboolean success = TRUE;

  args = ligma_value_array_new_from_types (NULL,
                                          G_TYPE_STRING, name,
                                          G_TYPE_INT, entry_num,
                                          LIGMA_TYPE_RGB, color,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-palette-entry-set-color",
                                              args);
  ligma_value_array_unref (args);

  success = LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS;

  ligma_value_array_unref (return_vals);

  return success;
}

/**
 * ligma_palette_entry_get_name:
 * @name: The palette name.
 * @entry_num: The entry to retrieve.
 * @entry_name: (out) (transfer full): The name requested.
 *
 * Gets the specified palette entry from the specified palette.
 *
 * This procedure retrieves the name of the zero-based entry specified
 * for the specified palette. It returns an error if the entry does not
 * exist.
 *
 * Returns: TRUE on success.
 *
 * Since: 2.2
 **/
gboolean
ligma_palette_entry_get_name (const gchar  *name,
                             gint          entry_num,
                             gchar       **entry_name)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gboolean success = TRUE;

  args = ligma_value_array_new_from_types (NULL,
                                          G_TYPE_STRING, name,
                                          G_TYPE_INT, entry_num,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-palette-entry-get-name",
                                              args);
  ligma_value_array_unref (args);

  *entry_name = NULL;

  success = LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS;

  if (success)
    *entry_name = LIGMA_VALUES_DUP_STRING (return_vals, 1);

  ligma_value_array_unref (return_vals);

  return success;
}

/**
 * ligma_palette_entry_set_name:
 * @name: The palette name.
 * @entry_num: The entry to retrieve.
 * @entry_name: The new name.
 *
 * Sets the specified palette entry in the specified palette.
 *
 * This procedure sets the name of the zero-based entry specified for
 * the specified palette. It returns an error if the entry does not
 * exist.
 *
 * Returns: TRUE on success.
 *
 * Since: 2.2
 **/
gboolean
ligma_palette_entry_set_name (const gchar *name,
                             gint         entry_num,
                             const gchar *entry_name)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gboolean success = TRUE;

  args = ligma_value_array_new_from_types (NULL,
                                          G_TYPE_STRING, name,
                                          G_TYPE_INT, entry_num,
                                          G_TYPE_STRING, entry_name,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-palette-entry-set-name",
                                              args);
  ligma_value_array_unref (args);

  success = LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS;

  ligma_value_array_unref (return_vals);

  return success;
}
