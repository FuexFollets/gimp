/* LIBLIGMA - The LIGMA Library
 * Copyright (C) 1995-2003 Peter Mattis and Spencer Kimball
 *
 * ligmalayer_pdb.c
 *
 * This library is free software: you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library.  If not, see
 * <https://www.gnu.org/licenses/>.
 */

/* NOTE: This file is auto-generated by pdbgen.pl */

#include "config.h"

#include "stamp-pdbgen.h"

#include "ligma.h"


/**
 * SECTION: ligmalayer
 * @title: ligmalayer
 * @short_description: Operations on a single layer.
 *
 * Operations on a single layer.
 **/


/**
 * _ligma_layer_new:
 * @image: The image to which to add the layer.
 * @width: The layer width.
 * @height: The layer height.
 * @type: The layer type.
 * @name: The layer name.
 * @opacity: The layer opacity.
 * @mode: The layer combination mode.
 *
 * Create a new layer.
 *
 * This procedure creates a new layer with the specified width, height,
 * and type. Name, opacity, and mode are also supplied parameters. The
 * new layer still needs to be added to the image, as this is not
 * automatic. Add the new layer with the ligma_image_insert_layer()
 * command. Other attributes such as layer mask modes, and offsets
 * should be set with explicit procedure calls.
 *
 * Returns: (transfer none): The newly created layer.
 **/
LigmaLayer *
_ligma_layer_new (LigmaImage     *image,
                 gint           width,
                 gint           height,
                 LigmaImageType  type,
                 const gchar   *name,
                 gdouble        opacity,
                 LigmaLayerMode  mode)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  LigmaLayer *layer = NULL;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_IMAGE, image,
                                          G_TYPE_INT, width,
                                          G_TYPE_INT, height,
                                          LIGMA_TYPE_IMAGE_TYPE, type,
                                          G_TYPE_STRING, name,
                                          G_TYPE_DOUBLE, opacity,
                                          LIGMA_TYPE_LAYER_MODE, mode,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-layer-new",
                                              args);
  ligma_value_array_unref (args);

  if (LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS)
    layer = LIGMA_VALUES_GET_LAYER (return_vals, 1);

  ligma_value_array_unref (return_vals);

  return layer;
}

/**
 * ligma_layer_new_from_visible:
 * @image: The source image from where the content is copied.
 * @dest_image: The destination image to which to add the layer.
 * @name: The layer name.
 *
 * Create a new layer from what is visible in an image.
 *
 * This procedure creates a new layer from what is visible in the given
 * image. The new layer still needs to be added to the destination
 * image, as this is not automatic. Add the new layer with the
 * ligma_image_insert_layer() command. Other attributes such as layer
 * mask modes, and offsets should be set with explicit procedure calls.
 *
 * Returns: (transfer none): The newly created layer.
 *
 * Since: 2.6
 **/
LigmaLayer *
ligma_layer_new_from_visible (LigmaImage   *image,
                             LigmaImage   *dest_image,
                             const gchar *name)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  LigmaLayer *layer = NULL;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_IMAGE, image,
                                          LIGMA_TYPE_IMAGE, dest_image,
                                          G_TYPE_STRING, name,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-layer-new-from-visible",
                                              args);
  ligma_value_array_unref (args);

  if (LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS)
    layer = LIGMA_VALUES_GET_LAYER (return_vals, 1);

  ligma_value_array_unref (return_vals);

  return layer;
}

/**
 * ligma_layer_new_from_drawable:
 * @drawable: The source drawable from where the new layer is copied.
 * @dest_image: The destination image to which to add the layer.
 *
 * Create a new layer by copying an existing drawable.
 *
 * This procedure creates a new layer as a copy of the specified
 * drawable. The new layer still needs to be added to the image, as
 * this is not automatic. Add the new layer with the
 * ligma_image_insert_layer() command. Other attributes such as layer
 * mask modes, and offsets should be set with explicit procedure calls.
 *
 * Returns: (transfer none): The newly copied layer.
 **/
LigmaLayer *
ligma_layer_new_from_drawable (LigmaDrawable *drawable,
                              LigmaImage    *dest_image)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  LigmaLayer *layer_copy = NULL;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_DRAWABLE, drawable,
                                          LIGMA_TYPE_IMAGE, dest_image,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-layer-new-from-drawable",
                                              args);
  ligma_value_array_unref (args);

  if (LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS)
    layer_copy = LIGMA_VALUES_GET_LAYER (return_vals, 1);

  ligma_value_array_unref (return_vals);

  return layer_copy;
}

/**
 * ligma_layer_group_new:
 * @image: The image to which to add the layer group.
 *
 * Create a new layer group.
 *
 * This procedure creates a new layer group. Attributes such as layer
 * mode and opacity should be set with explicit procedure calls. Add
 * the new layer group (which is a kind of layer) with the
 * ligma_image_insert_layer() command.
 * Other procedures useful with layer groups:
 * ligma_image_reorder_item(), ligma_item_get_parent(),
 * ligma_item_get_children(), ligma_item_is_group().
 *
 * Returns: (transfer none): The newly created layer group.
 *
 * Since: 2.8
 **/
LigmaLayer *
ligma_layer_group_new (LigmaImage *image)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  LigmaLayer *layer_group = NULL;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_IMAGE, image,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-layer-group-new",
                                              args);
  ligma_value_array_unref (args);

  if (LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS)
    layer_group = LIGMA_VALUES_GET_LAYER (return_vals, 1);

  ligma_value_array_unref (return_vals);

  return layer_group;
}

/**
 * _ligma_layer_copy:
 * @layer: The layer to copy.
 * @add_alpha: Add an alpha channel to the copied layer.
 *
 * Copy a layer.
 *
 * This procedure copies the specified layer and returns the copy. The
 * newly copied layer is for use within the original layer's image. It
 * should not be subsequently added to any other image. The copied
 * layer can optionally have an added alpha channel. This is useful if
 * the background layer in an image is being copied and added to the
 * same image.
 *
 * Returns: (transfer none): The newly copied layer.
 **/
LigmaLayer *
_ligma_layer_copy (LigmaLayer *layer,
                  gboolean   add_alpha)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  LigmaLayer *layer_copy = NULL;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_LAYER, layer,
                                          G_TYPE_BOOLEAN, add_alpha,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-layer-copy",
                                              args);
  ligma_value_array_unref (args);

  if (LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS)
    layer_copy = LIGMA_VALUES_GET_LAYER (return_vals, 1);

  ligma_value_array_unref (return_vals);

  return layer_copy;
}

/**
 * ligma_layer_add_alpha:
 * @layer: The layer.
 *
 * Add an alpha channel to the layer if it doesn't already have one.
 *
 * This procedure adds an additional component to the specified layer
 * if it does not already possess an alpha channel. An alpha channel
 * makes it possible to clear and erase to transparency, instead of the
 * background color. This transforms layers of type RGB to RGBA, GRAY
 * to GRAYA, and INDEXED to INDEXEDA.
 *
 * Returns: TRUE on success.
 **/
gboolean
ligma_layer_add_alpha (LigmaLayer *layer)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gboolean success = TRUE;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_LAYER, layer,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-layer-add-alpha",
                                              args);
  ligma_value_array_unref (args);

  success = LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS;

  ligma_value_array_unref (return_vals);

  return success;
}

/**
 * ligma_layer_flatten:
 * @layer: The layer.
 *
 * Remove the alpha channel from the layer if it has one.
 *
 * This procedure removes the alpha channel from a layer, blending all
 * (partially) transparent pixels in the layer against the background
 * color. This transforms layers of type RGBA to RGB, GRAYA to GRAY,
 * and INDEXEDA to INDEXED.
 *
 * Returns: TRUE on success.
 *
 * Since: 2.4
 **/
gboolean
ligma_layer_flatten (LigmaLayer *layer)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gboolean success = TRUE;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_LAYER, layer,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-layer-flatten",
                                              args);
  ligma_value_array_unref (args);

  success = LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS;

  ligma_value_array_unref (return_vals);

  return success;
}

/**
 * ligma_layer_scale:
 * @layer: The layer.
 * @new_width: New layer width.
 * @new_height: New layer height.
 * @local_origin: Use a local origin (as opposed to the image origin).
 *
 * Scale the layer using the default interpolation method.
 *
 * This procedure scales the layer so that its new width and height are
 * equal to the supplied parameters. The 'local-origin' parameter
 * specifies whether to scale from the center of the layer, or from the
 * image origin. This operation only works if the layer has been added
 * to an image. The interpolation method used can be set with
 * ligma_context_set_interpolation().
 *
 * Returns: TRUE on success.
 **/
gboolean
ligma_layer_scale (LigmaLayer *layer,
                  gint       new_width,
                  gint       new_height,
                  gboolean   local_origin)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gboolean success = TRUE;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_LAYER, layer,
                                          G_TYPE_INT, new_width,
                                          G_TYPE_INT, new_height,
                                          G_TYPE_BOOLEAN, local_origin,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-layer-scale",
                                              args);
  ligma_value_array_unref (args);

  success = LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS;

  ligma_value_array_unref (return_vals);

  return success;
}

/**
 * ligma_layer_resize:
 * @layer: The layer.
 * @new_width: New layer width.
 * @new_height: New layer height.
 * @offx: x offset between upper left corner of old and new layers: (old - new).
 * @offy: y offset between upper left corner of old and new layers: (old - new).
 *
 * Resize the layer to the specified extents.
 *
 * This procedure resizes the layer so that its new width and height
 * are equal to the supplied parameters. Offsets are also provided
 * which describe the position of the previous layer's content. This
 * operation only works if the layer has been added to an image.
 *
 * Returns: TRUE on success.
 **/
gboolean
ligma_layer_resize (LigmaLayer *layer,
                   gint       new_width,
                   gint       new_height,
                   gint       offx,
                   gint       offy)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gboolean success = TRUE;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_LAYER, layer,
                                          G_TYPE_INT, new_width,
                                          G_TYPE_INT, new_height,
                                          G_TYPE_INT, offx,
                                          G_TYPE_INT, offy,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-layer-resize",
                                              args);
  ligma_value_array_unref (args);

  success = LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS;

  ligma_value_array_unref (return_vals);

  return success;
}

/**
 * ligma_layer_resize_to_image_size:
 * @layer: The layer to resize.
 *
 * Resize a layer to the image size.
 *
 * This procedure resizes the layer so that it's new width and height
 * are equal to the width and height of its image container.
 *
 * Returns: TRUE on success.
 **/
gboolean
ligma_layer_resize_to_image_size (LigmaLayer *layer)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gboolean success = TRUE;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_LAYER, layer,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-layer-resize-to-image-size",
                                              args);
  ligma_value_array_unref (args);

  success = LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS;

  ligma_value_array_unref (return_vals);

  return success;
}

/**
 * ligma_layer_set_offsets:
 * @layer: The layer.
 * @offx: Offset in x direction.
 * @offy: Offset in y direction.
 *
 * Set the layer offsets.
 *
 * This procedure sets the offsets for the specified layer. The offsets
 * are relative to the image origin and can be any values. This
 * operation is valid only on layers which have been added to an image.
 *
 * Returns: TRUE on success.
 **/
gboolean
ligma_layer_set_offsets (LigmaLayer *layer,
                        gint       offx,
                        gint       offy)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gboolean success = TRUE;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_LAYER, layer,
                                          G_TYPE_INT, offx,
                                          G_TYPE_INT, offy,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-layer-set-offsets",
                                              args);
  ligma_value_array_unref (args);

  success = LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS;

  ligma_value_array_unref (return_vals);

  return success;
}

/**
 * ligma_layer_create_mask:
 * @layer: The layer to which to add the mask.
 * @mask_type: The type of mask.
 *
 * Create a layer mask for the specified layer.
 *
 * This procedure creates a layer mask for the specified layer.
 * Layer masks serve as an additional alpha channel for a layer.
 * Different types of masks are allowed for initialisation:
 * - white mask (leaves the layer fully visible);
 * - black mask (gives the layer complete transparency);
 * - the layer's alpha channel (either a copy, or a transfer, which
 * leaves the layer fully visible, but which may be more useful than a
 * white mask);
 * - the current selection;
 * - a grayscale copy of the layer;
 * - or a copy of the active channel.
 *
 * The layer mask still needs to be added to the layer. This can be
 * done with a call to ligma_layer_add_mask().
 *
 * ligma_layer_create_mask() will fail if there are no active channels
 * on the image, when called with 'ADD-CHANNEL-MASK'. It will return a
 * black mask when called with 'ADD-ALPHA-MASK' or
 * 'ADD-ALPHA-TRANSFER-MASK' on a layer with no alpha channels, or with
 * 'ADD-SELECTION-MASK' when there is no selection on the image.
 *
 * Returns: (transfer none): The newly created mask.
 **/
LigmaLayerMask *
ligma_layer_create_mask (LigmaLayer       *layer,
                        LigmaAddMaskType  mask_type)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  LigmaLayerMask *mask = NULL;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_LAYER, layer,
                                          LIGMA_TYPE_ADD_MASK_TYPE, mask_type,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-layer-create-mask",
                                              args);
  ligma_value_array_unref (args);

  if (LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS)
    mask = LIGMA_VALUES_GET_LAYER_MASK (return_vals, 1);

  ligma_value_array_unref (return_vals);

  return mask;
}

/**
 * ligma_layer_get_mask:
 * @layer: The layer.
 *
 * Get the specified layer's mask if it exists.
 *
 * This procedure returns the specified layer's mask, or -1 if none
 * exists.
 *
 * Returns: (transfer none): The layer mask.
 **/
LigmaLayerMask *
ligma_layer_get_mask (LigmaLayer *layer)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  LigmaLayerMask *mask = NULL;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_LAYER, layer,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-layer-get-mask",
                                              args);
  ligma_value_array_unref (args);

  if (LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS)
    mask = LIGMA_VALUES_GET_LAYER_MASK (return_vals, 1);

  ligma_value_array_unref (return_vals);

  return mask;
}

/**
 * ligma_layer_from_mask:
 * @mask: Mask for which to return the layer.
 *
 * Get the specified mask's layer.
 *
 * This procedure returns the specified mask's layer , or -1 if none
 * exists.
 *
 * Returns: (transfer none): The mask's layer.
 *
 * Since: 2.2
 **/
LigmaLayer *
ligma_layer_from_mask (LigmaLayerMask *mask)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  LigmaLayer *layer = NULL;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_LAYER_MASK, mask,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-layer-from-mask",
                                              args);
  ligma_value_array_unref (args);

  if (LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS)
    layer = LIGMA_VALUES_GET_LAYER (return_vals, 1);

  ligma_value_array_unref (return_vals);

  return layer;
}

/**
 * ligma_layer_add_mask:
 * @layer: The layer to receive the mask.
 * @mask: The mask to add to the layer.
 *
 * Add a layer mask to the specified layer.
 *
 * This procedure adds a layer mask to the specified layer. Layer masks
 * serve as an additional alpha channel for a layer. This procedure
 * will fail if a number of prerequisites aren't met. The layer cannot
 * already have a layer mask. The specified mask must exist and have
 * the same dimensions as the layer. The layer must have been created
 * for use with the specified image and the mask must have been created
 * with the procedure 'ligma-layer-create-mask'.
 *
 * Returns: TRUE on success.
 **/
gboolean
ligma_layer_add_mask (LigmaLayer     *layer,
                     LigmaLayerMask *mask)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gboolean success = TRUE;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_LAYER, layer,
                                          LIGMA_TYPE_LAYER_MASK, mask,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-layer-add-mask",
                                              args);
  ligma_value_array_unref (args);

  success = LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS;

  ligma_value_array_unref (return_vals);

  return success;
}

/**
 * ligma_layer_remove_mask:
 * @layer: The layer from which to remove mask.
 * @mode: Removal mode.
 *
 * Remove the specified layer mask from the layer.
 *
 * This procedure removes the specified layer mask from the layer. If
 * the mask doesn't exist, an error is returned.
 *
 * Returns: TRUE on success.
 **/
gboolean
ligma_layer_remove_mask (LigmaLayer         *layer,
                        LigmaMaskApplyMode  mode)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gboolean success = TRUE;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_LAYER, layer,
                                          LIGMA_TYPE_MASK_APPLY_MODE, mode,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-layer-remove-mask",
                                              args);
  ligma_value_array_unref (args);

  success = LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS;

  ligma_value_array_unref (return_vals);

  return success;
}

/**
 * ligma_layer_is_floating_sel:
 * @layer: The layer.
 *
 * Is the specified layer a floating selection?
 *
 * This procedure returns whether the layer is a floating selection.
 * Floating selections are special cases of layers which are attached
 * to a specific drawable.
 *
 * Returns: TRUE if the layer is a floating selection.
 **/
gboolean
ligma_layer_is_floating_sel (LigmaLayer *layer)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gboolean is_floating_sel = FALSE;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_LAYER, layer,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-layer-is-floating-sel",
                                              args);
  ligma_value_array_unref (args);

  if (LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS)
    is_floating_sel = LIGMA_VALUES_GET_BOOLEAN (return_vals, 1);

  ligma_value_array_unref (return_vals);

  return is_floating_sel;
}

/**
 * ligma_layer_get_lock_alpha:
 * @layer: The layer.
 *
 * Get the lock alpha channel setting of the specified layer.
 *
 * This procedure returns the specified layer's lock alpha channel
 * setting.
 *
 * Returns: The layer's lock alpha channel setting.
 **/
gboolean
ligma_layer_get_lock_alpha (LigmaLayer *layer)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gboolean lock_alpha = FALSE;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_LAYER, layer,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-layer-get-lock-alpha",
                                              args);
  ligma_value_array_unref (args);

  if (LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS)
    lock_alpha = LIGMA_VALUES_GET_BOOLEAN (return_vals, 1);

  ligma_value_array_unref (return_vals);

  return lock_alpha;
}

/**
 * ligma_layer_set_lock_alpha:
 * @layer: The layer.
 * @lock_alpha: The new layer's lock alpha channel setting.
 *
 * Set the lock alpha channel setting of the specified layer.
 *
 * This procedure sets the specified layer's lock alpha channel
 * setting.
 *
 * Returns: TRUE on success.
 **/
gboolean
ligma_layer_set_lock_alpha (LigmaLayer *layer,
                           gboolean   lock_alpha)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gboolean success = TRUE;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_LAYER, layer,
                                          G_TYPE_BOOLEAN, lock_alpha,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-layer-set-lock-alpha",
                                              args);
  ligma_value_array_unref (args);

  success = LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS;

  ligma_value_array_unref (return_vals);

  return success;
}

/**
 * ligma_layer_get_apply_mask:
 * @layer: The layer.
 *
 * Get the apply mask setting of the specified layer.
 *
 * This procedure returns the specified layer's apply mask setting. If
 * the value is TRUE, then the layer mask for this layer is currently
 * being composited with the layer's alpha channel.
 *
 * Returns: The layer's apply mask setting.
 **/
gboolean
ligma_layer_get_apply_mask (LigmaLayer *layer)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gboolean apply_mask = FALSE;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_LAYER, layer,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-layer-get-apply-mask",
                                              args);
  ligma_value_array_unref (args);

  if (LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS)
    apply_mask = LIGMA_VALUES_GET_BOOLEAN (return_vals, 1);

  ligma_value_array_unref (return_vals);

  return apply_mask;
}

/**
 * ligma_layer_set_apply_mask:
 * @layer: The layer.
 * @apply_mask: The new layer's apply mask setting.
 *
 * Set the apply mask setting of the specified layer.
 *
 * This procedure sets the specified layer's apply mask setting. This
 * controls whether the layer's mask is currently affecting the alpha
 * channel. If there is no layer mask, this function will return an
 * error.
 *
 * Returns: TRUE on success.
 **/
gboolean
ligma_layer_set_apply_mask (LigmaLayer *layer,
                           gboolean   apply_mask)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gboolean success = TRUE;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_LAYER, layer,
                                          G_TYPE_BOOLEAN, apply_mask,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-layer-set-apply-mask",
                                              args);
  ligma_value_array_unref (args);

  success = LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS;

  ligma_value_array_unref (return_vals);

  return success;
}

/**
 * ligma_layer_get_show_mask:
 * @layer: The layer.
 *
 * Get the show mask setting of the specified layer.
 *
 * This procedure returns the specified layer's show mask setting. This
 * controls whether the layer or its mask is visible. TRUE indicates
 * that the mask should be visible. If the layer has no mask, then this
 * function returns an error.
 *
 * Returns: The layer's show mask setting.
 **/
gboolean
ligma_layer_get_show_mask (LigmaLayer *layer)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gboolean show_mask = FALSE;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_LAYER, layer,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-layer-get-show-mask",
                                              args);
  ligma_value_array_unref (args);

  if (LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS)
    show_mask = LIGMA_VALUES_GET_BOOLEAN (return_vals, 1);

  ligma_value_array_unref (return_vals);

  return show_mask;
}

/**
 * ligma_layer_set_show_mask:
 * @layer: The layer.
 * @show_mask: The new layer's show mask setting.
 *
 * Set the show mask setting of the specified layer.
 *
 * This procedure sets the specified layer's show mask setting. This
 * controls whether the layer or its mask is visible. TRUE indicates
 * that the mask should be visible. If there is no layer mask, this
 * function will return an error.
 *
 * Returns: TRUE on success.
 **/
gboolean
ligma_layer_set_show_mask (LigmaLayer *layer,
                          gboolean   show_mask)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gboolean success = TRUE;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_LAYER, layer,
                                          G_TYPE_BOOLEAN, show_mask,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-layer-set-show-mask",
                                              args);
  ligma_value_array_unref (args);

  success = LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS;

  ligma_value_array_unref (return_vals);

  return success;
}

/**
 * ligma_layer_get_edit_mask:
 * @layer: The layer.
 *
 * Get the edit mask setting of the specified layer.
 *
 * This procedure returns the specified layer's edit mask setting. If
 * the value is TRUE, then the layer mask for this layer is currently
 * active, and not the layer.
 *
 * Returns: The layer's edit mask setting.
 **/
gboolean
ligma_layer_get_edit_mask (LigmaLayer *layer)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gboolean edit_mask = FALSE;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_LAYER, layer,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-layer-get-edit-mask",
                                              args);
  ligma_value_array_unref (args);

  if (LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS)
    edit_mask = LIGMA_VALUES_GET_BOOLEAN (return_vals, 1);

  ligma_value_array_unref (return_vals);

  return edit_mask;
}

/**
 * ligma_layer_set_edit_mask:
 * @layer: The layer.
 * @edit_mask: The new layer's edit mask setting.
 *
 * Set the edit mask setting of the specified layer.
 *
 * This procedure sets the specified layer's edit mask setting. This
 * controls whether the layer or it's mask is currently active for
 * editing. If the specified layer has no layer mask, then this
 * procedure will return an error.
 *
 * Returns: TRUE on success.
 **/
gboolean
ligma_layer_set_edit_mask (LigmaLayer *layer,
                          gboolean   edit_mask)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gboolean success = TRUE;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_LAYER, layer,
                                          G_TYPE_BOOLEAN, edit_mask,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-layer-set-edit-mask",
                                              args);
  ligma_value_array_unref (args);

  success = LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS;

  ligma_value_array_unref (return_vals);

  return success;
}

/**
 * ligma_layer_get_opacity:
 * @layer: The layer.
 *
 * Get the opacity of the specified layer.
 *
 * This procedure returns the specified layer's opacity.
 *
 * Returns: The layer opacity.
 **/
gdouble
ligma_layer_get_opacity (LigmaLayer *layer)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gdouble opacity = 0.0;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_LAYER, layer,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-layer-get-opacity",
                                              args);
  ligma_value_array_unref (args);

  if (LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS)
    opacity = LIGMA_VALUES_GET_DOUBLE (return_vals, 1);

  ligma_value_array_unref (return_vals);

  return opacity;
}

/**
 * ligma_layer_set_opacity:
 * @layer: The layer.
 * @opacity: The new layer opacity.
 *
 * Set the opacity of the specified layer.
 *
 * This procedure sets the specified layer's opacity.
 *
 * Returns: TRUE on success.
 **/
gboolean
ligma_layer_set_opacity (LigmaLayer *layer,
                        gdouble    opacity)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gboolean success = TRUE;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_LAYER, layer,
                                          G_TYPE_DOUBLE, opacity,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-layer-set-opacity",
                                              args);
  ligma_value_array_unref (args);

  success = LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS;

  ligma_value_array_unref (return_vals);

  return success;
}

/**
 * ligma_layer_get_mode:
 * @layer: The layer.
 *
 * Get the combination mode of the specified layer.
 *
 * This procedure returns the specified layer's combination mode.
 *
 * Returns: The layer combination mode.
 **/
LigmaLayerMode
ligma_layer_get_mode (LigmaLayer *layer)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  LigmaLayerMode mode = 0;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_LAYER, layer,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-layer-get-mode",
                                              args);
  ligma_value_array_unref (args);

  if (LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS)
    mode = LIGMA_VALUES_GET_ENUM (return_vals, 1);

  ligma_value_array_unref (return_vals);

  return mode;
}

/**
 * ligma_layer_set_mode:
 * @layer: The layer.
 * @mode: The new layer combination mode.
 *
 * Set the combination mode of the specified layer.
 *
 * This procedure sets the specified layer's combination mode.
 *
 * Returns: TRUE on success.
 **/
gboolean
ligma_layer_set_mode (LigmaLayer     *layer,
                     LigmaLayerMode  mode)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gboolean success = TRUE;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_LAYER, layer,
                                          LIGMA_TYPE_LAYER_MODE, mode,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-layer-set-mode",
                                              args);
  ligma_value_array_unref (args);

  success = LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS;

  ligma_value_array_unref (return_vals);

  return success;
}

/**
 * ligma_layer_get_blend_space:
 * @layer: The layer.
 *
 * Get the blend space of the specified layer.
 *
 * This procedure returns the specified layer's blend space.
 *
 * Returns: The layer blend space.
 *
 * Since: 2.10
 **/
LigmaLayerColorSpace
ligma_layer_get_blend_space (LigmaLayer *layer)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  LigmaLayerColorSpace blend_space = 0;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_LAYER, layer,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-layer-get-blend-space",
                                              args);
  ligma_value_array_unref (args);

  if (LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS)
    blend_space = LIGMA_VALUES_GET_ENUM (return_vals, 1);

  ligma_value_array_unref (return_vals);

  return blend_space;
}

/**
 * ligma_layer_set_blend_space:
 * @layer: The layer.
 * @blend_space: The new layer blend space.
 *
 * Set the blend space of the specified layer.
 *
 * This procedure sets the specified layer's blend space.
 *
 * Returns: TRUE on success.
 *
 * Since: 2.10
 **/
gboolean
ligma_layer_set_blend_space (LigmaLayer           *layer,
                            LigmaLayerColorSpace  blend_space)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gboolean success = TRUE;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_LAYER, layer,
                                          LIGMA_TYPE_LAYER_COLOR_SPACE, blend_space,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-layer-set-blend-space",
                                              args);
  ligma_value_array_unref (args);

  success = LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS;

  ligma_value_array_unref (return_vals);

  return success;
}

/**
 * ligma_layer_get_composite_space:
 * @layer: The layer.
 *
 * Get the composite space of the specified layer.
 *
 * This procedure returns the specified layer's composite space.
 *
 * Returns: The layer composite space.
 *
 * Since: 2.10
 **/
LigmaLayerColorSpace
ligma_layer_get_composite_space (LigmaLayer *layer)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  LigmaLayerColorSpace composite_space = 0;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_LAYER, layer,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-layer-get-composite-space",
                                              args);
  ligma_value_array_unref (args);

  if (LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS)
    composite_space = LIGMA_VALUES_GET_ENUM (return_vals, 1);

  ligma_value_array_unref (return_vals);

  return composite_space;
}

/**
 * ligma_layer_set_composite_space:
 * @layer: The layer.
 * @composite_space: The new layer composite space.
 *
 * Set the composite space of the specified layer.
 *
 * This procedure sets the specified layer's composite space.
 *
 * Returns: TRUE on success.
 *
 * Since: 2.10
 **/
gboolean
ligma_layer_set_composite_space (LigmaLayer           *layer,
                                LigmaLayerColorSpace  composite_space)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gboolean success = TRUE;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_LAYER, layer,
                                          LIGMA_TYPE_LAYER_COLOR_SPACE, composite_space,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-layer-set-composite-space",
                                              args);
  ligma_value_array_unref (args);

  success = LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS;

  ligma_value_array_unref (return_vals);

  return success;
}

/**
 * ligma_layer_get_composite_mode:
 * @layer: The layer.
 *
 * Get the composite mode of the specified layer.
 *
 * This procedure returns the specified layer's composite mode.
 *
 * Returns: The layer composite mode.
 *
 * Since: 2.10
 **/
LigmaLayerCompositeMode
ligma_layer_get_composite_mode (LigmaLayer *layer)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  LigmaLayerCompositeMode composite_mode = 0;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_LAYER, layer,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-layer-get-composite-mode",
                                              args);
  ligma_value_array_unref (args);

  if (LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS)
    composite_mode = LIGMA_VALUES_GET_ENUM (return_vals, 1);

  ligma_value_array_unref (return_vals);

  return composite_mode;
}

/**
 * ligma_layer_set_composite_mode:
 * @layer: The layer.
 * @composite_mode: The new layer composite mode.
 *
 * Set the composite mode of the specified layer.
 *
 * This procedure sets the specified layer's composite mode.
 *
 * Returns: TRUE on success.
 *
 * Since: 2.10
 **/
gboolean
ligma_layer_set_composite_mode (LigmaLayer              *layer,
                               LigmaLayerCompositeMode  composite_mode)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gboolean success = TRUE;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_LAYER, layer,
                                          LIGMA_TYPE_LAYER_COMPOSITE_MODE, composite_mode,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-layer-set-composite-mode",
                                              args);
  ligma_value_array_unref (args);

  success = LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS;

  ligma_value_array_unref (return_vals);

  return success;
}
