/* LIBLIGMA - The LIGMA Library
 * Copyright (C) 1995-2003 Peter Mattis and Spencer Kimball
 *
 * ligmaunit_pdb.c
 *
 * This library is free software: you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library.  If not, see
 * <https://www.gnu.org/licenses/>.
 */

/* NOTE: This file is auto-generated by pdbgen.pl */

#include "config.h"

#include "stamp-pdbgen.h"

#include "ligma.h"
#include "ligmaunit_pdb.h"

/**
 * _ligma_unit_get_number_of_units:
 *
 * Returns the number of units.
 *
 * This procedure returns the number of defined units.
 *
 * Returns: The number of units.
 **/
gint
_ligma_unit_get_number_of_units (void)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gint num_units = LIGMA_UNIT_END;

  args = ligma_value_array_new_from_types (NULL,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-unit-get-number-of-units",
                                              args);
  ligma_value_array_unref (args);

  if (LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS)
    num_units = LIGMA_VALUES_GET_INT (return_vals, 1);

  ligma_value_array_unref (return_vals);

  return num_units;
}

/**
 * _ligma_unit_get_number_of_built_in_units:
 *
 * Returns the number of built-in units.
 *
 * This procedure returns the number of defined units built-in to LIGMA.
 *
 * Returns: The number of built-in units.
 **/
gint
_ligma_unit_get_number_of_built_in_units (void)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gint num_units = LIGMA_UNIT_END;

  args = ligma_value_array_new_from_types (NULL,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-unit-get-number-of-built-in-units",
                                              args);
  ligma_value_array_unref (args);

  if (LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS)
    num_units = LIGMA_VALUES_GET_INT (return_vals, 1);

  ligma_value_array_unref (return_vals);

  return num_units;
}

/**
 * _ligma_unit_new:
 * @identifier: The new unit's identifier.
 * @factor: The new unit's factor.
 * @digits: The new unit's digits.
 * @symbol: The new unit's symbol.
 * @abbreviation: The new unit's abbreviation.
 * @singular: The new unit's singular form.
 * @plural: The new unit's plural form.
 *
 * Creates a new unit and returns it's integer ID.
 *
 * This procedure creates a new unit and returns it's integer ID. Note
 * that the new unit will have it's deletion flag set to TRUE, so you
 * will have to set it to FALSE with ligma_unit_set_deletion_flag() to
 * make it persistent.
 *
 * Returns: (transfer none): The new unit's ID.
 **/
LigmaUnit
_ligma_unit_new (const gchar *identifier,
                gdouble      factor,
                gint         digits,
                const gchar *symbol,
                const gchar *abbreviation,
                const gchar *singular,
                const gchar *plural)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  LigmaUnit unit_id = LIGMA_UNIT_INCH;

  args = ligma_value_array_new_from_types (NULL,
                                          G_TYPE_STRING, identifier,
                                          G_TYPE_DOUBLE, factor,
                                          G_TYPE_INT, digits,
                                          G_TYPE_STRING, symbol,
                                          G_TYPE_STRING, abbreviation,
                                          G_TYPE_STRING, singular,
                                          G_TYPE_STRING, plural,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-unit-new",
                                              args);
  ligma_value_array_unref (args);

  if (LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS)
    unit_id = LIGMA_VALUES_GET_INT (return_vals, 1);

  ligma_value_array_unref (return_vals);

  return unit_id;
}

/**
 * _ligma_unit_get_deletion_flag:
 * @unit_id: The unit's integer ID.
 *
 * Returns the deletion flag of the unit.
 *
 * This procedure returns the deletion flag of the unit. If this value
 * is TRUE the unit's definition will not be saved in the user's unitrc
 * file on ligma exit.
 *
 * Returns: The unit's deletion flag.
 **/
gboolean
_ligma_unit_get_deletion_flag (LigmaUnit unit_id)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gboolean deletion_flag = FALSE;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_UNIT, unit_id,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-unit-get-deletion-flag",
                                              args);
  ligma_value_array_unref (args);

  if (LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS)
    deletion_flag = LIGMA_VALUES_GET_BOOLEAN (return_vals, 1);

  ligma_value_array_unref (return_vals);

  return deletion_flag;
}

/**
 * _ligma_unit_set_deletion_flag:
 * @unit_id: The unit's integer ID.
 * @deletion_flag: The new deletion flag of the unit.
 *
 * Sets the deletion flag of a unit.
 *
 * This procedure sets the unit's deletion flag. If the deletion flag
 * of a unit is TRUE on ligma exit, this unit's definition will not be
 * saved in the user's unitrc.
 *
 * Returns: TRUE on success.
 **/
gboolean
_ligma_unit_set_deletion_flag (LigmaUnit unit_id,
                              gboolean deletion_flag)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gboolean success = TRUE;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_UNIT, unit_id,
                                          G_TYPE_BOOLEAN, deletion_flag,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-unit-set-deletion-flag",
                                              args);
  ligma_value_array_unref (args);

  success = LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS;

  ligma_value_array_unref (return_vals);

  return success;
}

/**
 * _ligma_unit_get_identifier:
 * @unit_id: The unit's integer ID.
 *
 * Returns the textual identifier of the unit.
 *
 * This procedure returns the textual identifier of the unit. For
 * built-in units it will be the english singular form of the unit's
 * name. For user-defined units this should equal to the singular form.
 *
 * Returns: (transfer full): The unit's textual identifier.
 *          The returned value must be freed with g_free().
 **/
gchar *
_ligma_unit_get_identifier (LigmaUnit unit_id)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gchar *identifier = NULL;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_UNIT, unit_id,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-unit-get-identifier",
                                              args);
  ligma_value_array_unref (args);

  if (LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS)
    identifier = LIGMA_VALUES_DUP_STRING (return_vals, 1);

  ligma_value_array_unref (return_vals);

  return identifier;
}

/**
 * _ligma_unit_get_factor:
 * @unit_id: The unit's integer ID.
 *
 * Returns the factor of the unit.
 *
 * This procedure returns the unit's factor which indicates how many
 * units make up an inch. Note that asking for the factor of \"pixels\"
 * will produce an error.
 *
 * Returns: The unit's factor.
 **/
gdouble
_ligma_unit_get_factor (LigmaUnit unit_id)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gdouble factor = 0.0;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_UNIT, unit_id,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-unit-get-factor",
                                              args);
  ligma_value_array_unref (args);

  if (LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS)
    factor = LIGMA_VALUES_GET_DOUBLE (return_vals, 1);

  ligma_value_array_unref (return_vals);

  return factor;
}

/**
 * _ligma_unit_get_digits:
 * @unit_id: The unit's integer ID.
 *
 * Returns the number of digits of the unit.
 *
 * This procedure returns the number of digits you should provide in
 * input or output functions to get approximately the same accuracy as
 * with two digits and inches. Note that asking for the digits of
 * \"pixels\" will produce an error.
 *
 * Returns: The unit's number of digits.
 **/
gint
_ligma_unit_get_digits (LigmaUnit unit_id)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gint digits = 0;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_UNIT, unit_id,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-unit-get-digits",
                                              args);
  ligma_value_array_unref (args);

  if (LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS)
    digits = LIGMA_VALUES_GET_INT (return_vals, 1);

  ligma_value_array_unref (return_vals);

  return digits;
}

/**
 * _ligma_unit_get_symbol:
 * @unit_id: The unit's integer ID.
 *
 * Returns the symbol of the unit.
 *
 * This procedure returns the symbol of the unit (\"''\" for inches).
 *
 * Returns: (transfer full): The unit's symbol.
 *          The returned value must be freed with g_free().
 **/
gchar *
_ligma_unit_get_symbol (LigmaUnit unit_id)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gchar *symbol = NULL;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_UNIT, unit_id,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-unit-get-symbol",
                                              args);
  ligma_value_array_unref (args);

  if (LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS)
    symbol = LIGMA_VALUES_DUP_STRING (return_vals, 1);

  ligma_value_array_unref (return_vals);

  return symbol;
}

/**
 * _ligma_unit_get_abbreviation:
 * @unit_id: The unit's integer ID.
 *
 * Returns the abbreviation of the unit.
 *
 * This procedure returns the abbreviation of the unit (\"in\" for
 * inches).
 *
 * Returns: (transfer full): The unit's abbreviation.
 *          The returned value must be freed with g_free().
 **/
gchar *
_ligma_unit_get_abbreviation (LigmaUnit unit_id)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gchar *abbreviation = NULL;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_UNIT, unit_id,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-unit-get-abbreviation",
                                              args);
  ligma_value_array_unref (args);

  if (LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS)
    abbreviation = LIGMA_VALUES_DUP_STRING (return_vals, 1);

  ligma_value_array_unref (return_vals);

  return abbreviation;
}

/**
 * _ligma_unit_get_singular:
 * @unit_id: The unit's integer ID.
 *
 * Returns the singular form of the unit.
 *
 * This procedure returns the singular form of the unit.
 *
 * Returns: (transfer full): The unit's singular form.
 *          The returned value must be freed with g_free().
 **/
gchar *
_ligma_unit_get_singular (LigmaUnit unit_id)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gchar *singular = NULL;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_UNIT, unit_id,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-unit-get-singular",
                                              args);
  ligma_value_array_unref (args);

  if (LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS)
    singular = LIGMA_VALUES_DUP_STRING (return_vals, 1);

  ligma_value_array_unref (return_vals);

  return singular;
}

/**
 * _ligma_unit_get_plural:
 * @unit_id: The unit's integer ID.
 *
 * Returns the plural form of the unit.
 *
 * This procedure returns the plural form of the unit.
 *
 * Returns: (transfer full): The unit's plural form.
 *          The returned value must be freed with g_free().
 **/
gchar *
_ligma_unit_get_plural (LigmaUnit unit_id)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gchar *plural = NULL;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_UNIT, unit_id,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-unit-get-plural",
                                              args);
  ligma_value_array_unref (args);

  if (LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS)
    plural = LIGMA_VALUES_DUP_STRING (return_vals, 1);

  ligma_value_array_unref (return_vals);

  return plural;
}
