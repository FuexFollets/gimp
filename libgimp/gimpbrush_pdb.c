/* LIBLIGMA - The LIGMA Library
 * Copyright (C) 1995-2003 Peter Mattis and Spencer Kimball
 *
 * ligmabrush_pdb.c
 *
 * This library is free software: you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library.  If not, see
 * <https://www.gnu.org/licenses/>.
 */

/* NOTE: This file is auto-generated by pdbgen.pl */

#include "config.h"

#include "stamp-pdbgen.h"

#include "ligma.h"


/**
 * SECTION: ligmabrush
 * @title: ligmabrush
 * @short_description: Functions operating on a single brush.
 *
 * Functions operating on a single brush.
 **/


/**
 * ligma_brush_new:
 * @name: The requested name of the new brush.
 *
 * Creates a new brush.
 *
 * This procedure creates a new, uninitialized brush.
 *
 * Returns: (transfer full): The actual new brush name.
 *          The returned value must be freed with g_free().
 *
 * Since: 2.2
 **/
gchar *
ligma_brush_new (const gchar *name)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gchar *actual_name = NULL;

  args = ligma_value_array_new_from_types (NULL,
                                          G_TYPE_STRING, name,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-brush-new",
                                              args);
  ligma_value_array_unref (args);

  if (LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS)
    actual_name = LIGMA_VALUES_DUP_STRING (return_vals, 1);

  ligma_value_array_unref (return_vals);

  return actual_name;
}

/**
 * ligma_brush_duplicate:
 * @name: The brush name.
 *
 * Duplicates a brush.
 *
 * This procedure creates an identical brush by a different name.
 *
 * Returns: (transfer full): The name of the brush's copy.
 *          The returned value must be freed with g_free().
 *
 * Since: 2.2
 **/
gchar *
ligma_brush_duplicate (const gchar *name)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gchar *copy_name = NULL;

  args = ligma_value_array_new_from_types (NULL,
                                          G_TYPE_STRING, name,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-brush-duplicate",
                                              args);
  ligma_value_array_unref (args);

  if (LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS)
    copy_name = LIGMA_VALUES_DUP_STRING (return_vals, 1);

  ligma_value_array_unref (return_vals);

  return copy_name;
}

/**
 * ligma_brush_is_generated:
 * @name: The brush name.
 *
 * Tests if brush is generated.
 *
 * Returns TRUE if this brush is parametric, FALSE for other types.
 *
 * Returns: TRUE if the brush is generated.
 *
 * Since: 2.4
 **/
gboolean
ligma_brush_is_generated (const gchar *name)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gboolean generated = FALSE;

  args = ligma_value_array_new_from_types (NULL,
                                          G_TYPE_STRING, name,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-brush-is-generated",
                                              args);
  ligma_value_array_unref (args);

  if (LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS)
    generated = LIGMA_VALUES_GET_BOOLEAN (return_vals, 1);

  ligma_value_array_unref (return_vals);

  return generated;
}

/**
 * ligma_brush_rename:
 * @name: The brush name.
 * @new_name: The new name of the brush.
 *
 * Renames a brush.
 *
 * This procedure renames a brush.
 *
 * Returns: (transfer full): The actual new name of the brush.
 *          The returned value must be freed with g_free().
 *
 * Since: 2.2
 **/
gchar *
ligma_brush_rename (const gchar *name,
                   const gchar *new_name)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gchar *actual_name = NULL;

  args = ligma_value_array_new_from_types (NULL,
                                          G_TYPE_STRING, name,
                                          G_TYPE_STRING, new_name,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-brush-rename",
                                              args);
  ligma_value_array_unref (args);

  if (LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS)
    actual_name = LIGMA_VALUES_DUP_STRING (return_vals, 1);

  ligma_value_array_unref (return_vals);

  return actual_name;
}

/**
 * ligma_brush_delete:
 * @name: The brush name.
 *
 * Deletes a brush.
 *
 * This procedure deletes a brush.
 *
 * Returns: TRUE on success.
 *
 * Since: 2.2
 **/
gboolean
ligma_brush_delete (const gchar *name)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gboolean success = TRUE;

  args = ligma_value_array_new_from_types (NULL,
                                          G_TYPE_STRING, name,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-brush-delete",
                                              args);
  ligma_value_array_unref (args);

  success = LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS;

  ligma_value_array_unref (return_vals);

  return success;
}

/**
 * ligma_brush_is_editable:
 * @name: The brush name.
 *
 * Tests if brush can be edited.
 *
 * Returns TRUE if you have permission to change the brush.
 *
 * Returns: TRUE if the brush can be edited.
 *
 * Since: 2.4
 **/
gboolean
ligma_brush_is_editable (const gchar *name)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gboolean editable = FALSE;

  args = ligma_value_array_new_from_types (NULL,
                                          G_TYPE_STRING, name,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-brush-is-editable",
                                              args);
  ligma_value_array_unref (args);

  if (LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS)
    editable = LIGMA_VALUES_GET_BOOLEAN (return_vals, 1);

  ligma_value_array_unref (return_vals);

  return editable;
}

/**
 * ligma_brush_get_info:
 * @name: The brush name.
 * @width: (out): The brush width.
 * @height: (out): The brush height.
 * @mask_bpp: (out): The brush mask bpp.
 * @color_bpp: (out): The brush color bpp.
 *
 * Retrieves information about the specified brush.
 *
 * This procedure retrieves information about the specified brush:
 * brush extents (width and height), color depth and mask depth.
 *
 * Returns: TRUE on success.
 *
 * Since: 2.2
 **/
gboolean
ligma_brush_get_info (const gchar *name,
                     gint        *width,
                     gint        *height,
                     gint        *mask_bpp,
                     gint        *color_bpp)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gboolean success = TRUE;

  args = ligma_value_array_new_from_types (NULL,
                                          G_TYPE_STRING, name,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-brush-get-info",
                                              args);
  ligma_value_array_unref (args);

  *width = 0;
  *height = 0;
  *mask_bpp = 0;
  *color_bpp = 0;

  success = LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS;

  if (success)
    {
      *width = LIGMA_VALUES_GET_INT (return_vals, 1);
      *height = LIGMA_VALUES_GET_INT (return_vals, 2);
      *mask_bpp = LIGMA_VALUES_GET_INT (return_vals, 3);
      *color_bpp = LIGMA_VALUES_GET_INT (return_vals, 4);
    }

  ligma_value_array_unref (return_vals);

  return success;
}

/**
 * ligma_brush_get_pixels:
 * @name: The brush name.
 * @width: (out): The brush width.
 * @height: (out): The brush height.
 * @mask_bpp: (out): The brush mask bpp.
 * @num_mask_bytes: (out): Length of brush mask data.
 * @mask_bytes: (out) (array length=num_mask_bytes) (element-type guint8) (transfer full): The brush mask data.
 * @color_bpp: (out): The brush color bpp.
 * @num_color_bytes: (out): Length of brush color data.
 * @color_bytes: (out) (array length=num_color_bytes) (element-type guint8) (transfer full): The brush color data.
 *
 * Retrieves information about the specified brush.
 *
 * This procedure retrieves information about the specified brush. This
 * includes the brush extents (width and height) and its pixels data.
 *
 * Returns: TRUE on success.
 *
 * Since: 2.2
 **/
gboolean
ligma_brush_get_pixels (const gchar  *name,
                       gint         *width,
                       gint         *height,
                       gint         *mask_bpp,
                       gint         *num_mask_bytes,
                       guint8      **mask_bytes,
                       gint         *color_bpp,
                       gint         *num_color_bytes,
                       guint8      **color_bytes)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gboolean success = TRUE;

  args = ligma_value_array_new_from_types (NULL,
                                          G_TYPE_STRING, name,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-brush-get-pixels",
                                              args);
  ligma_value_array_unref (args);

  *width = 0;
  *height = 0;
  *mask_bpp = 0;
  *num_mask_bytes = 0;
  *mask_bytes = NULL;
  *color_bpp = 0;
  *num_color_bytes = 0;
  *color_bytes = NULL;

  success = LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS;

  if (success)
    {
      *width = LIGMA_VALUES_GET_INT (return_vals, 1);
      *height = LIGMA_VALUES_GET_INT (return_vals, 2);
      *mask_bpp = LIGMA_VALUES_GET_INT (return_vals, 3);
      *num_mask_bytes = LIGMA_VALUES_GET_INT (return_vals, 4);
      *mask_bytes = LIGMA_VALUES_DUP_UINT8_ARRAY (return_vals, 5);
      *color_bpp = LIGMA_VALUES_GET_INT (return_vals, 6);
      *num_color_bytes = LIGMA_VALUES_GET_INT (return_vals, 7);
      *color_bytes = LIGMA_VALUES_DUP_UINT8_ARRAY (return_vals, 8);
    }

  ligma_value_array_unref (return_vals);

  return success;
}

/**
 * ligma_brush_get_spacing:
 * @name: The brush name.
 * @spacing: (out): The brush spacing.
 *
 * Gets the brush spacing.
 *
 * This procedure returns the spacing setting for the specified brush.
 * The return value is an integer between 0 and 1000 which represents
 * percentage of the maximum of the width and height of the mask.
 *
 * Returns: TRUE on success.
 *
 * Since: 2.2
 **/
gboolean
ligma_brush_get_spacing (const gchar *name,
                        gint        *spacing)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gboolean success = TRUE;

  args = ligma_value_array_new_from_types (NULL,
                                          G_TYPE_STRING, name,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-brush-get-spacing",
                                              args);
  ligma_value_array_unref (args);

  *spacing = 0;

  success = LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS;

  if (success)
    *spacing = LIGMA_VALUES_GET_INT (return_vals, 1);

  ligma_value_array_unref (return_vals);

  return success;
}

/**
 * ligma_brush_set_spacing:
 * @name: The brush name.
 * @spacing: The brush spacing.
 *
 * Sets the brush spacing.
 *
 * This procedure modifies the spacing setting for the specified brush.
 * The value should be a integer between 0 and 1000.
 *
 * Returns: TRUE on success.
 *
 * Since: 2.4
 **/
gboolean
ligma_brush_set_spacing (const gchar *name,
                        gint         spacing)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gboolean success = TRUE;

  args = ligma_value_array_new_from_types (NULL,
                                          G_TYPE_STRING, name,
                                          G_TYPE_INT, spacing,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-brush-set-spacing",
                                              args);
  ligma_value_array_unref (args);

  success = LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS;

  ligma_value_array_unref (return_vals);

  return success;
}

/**
 * ligma_brush_get_shape:
 * @name: The brush name.
 *
 * Gets the shape of a generated brush.
 *
 * This procedure gets the shape value for a generated brush. If called
 * for any other type of brush, it does not succeed. The current
 * possibilities are Circle (LIGMA_BRUSH_GENERATED_CIRCLE), Square
 * (LIGMA_BRUSH_GENERATED_SQUARE), and Diamond
 * (LIGMA_BRUSH_GENERATED_DIAMOND). Other shapes are likely to be added
 * in the future.
 *
 * Returns: The brush shape.
 *
 * Since: 2.4
 **/
LigmaBrushGeneratedShape
ligma_brush_get_shape (const gchar *name)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  LigmaBrushGeneratedShape shape = 0;

  args = ligma_value_array_new_from_types (NULL,
                                          G_TYPE_STRING, name,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-brush-get-shape",
                                              args);
  ligma_value_array_unref (args);

  if (LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS)
    shape = LIGMA_VALUES_GET_ENUM (return_vals, 1);

  ligma_value_array_unref (return_vals);

  return shape;
}

/**
 * ligma_brush_set_shape:
 * @name: The brush name.
 * @shape_in: The brush shape.
 *
 * Sets the shape of a generated brush.
 *
 * This procedure sets the shape value for a generated brush. If called
 * for any other type of brush, it does not succeed. The current
 * possibilities are Circle (LIGMA_BRUSH_GENERATED_CIRCLE), Square
 * (LIGMA_BRUSH_GENERATED_SQUARE), and Diamond
 * (LIGMA_BRUSH_GENERATED_DIAMOND). Other shapes are likely to be added
 * in the future.
 *
 * Returns: The brush shape actually assigned.
 *
 * Since: 2.4
 **/
LigmaBrushGeneratedShape
ligma_brush_set_shape (const gchar             *name,
                      LigmaBrushGeneratedShape  shape_in)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  LigmaBrushGeneratedShape shape_out = 0;

  args = ligma_value_array_new_from_types (NULL,
                                          G_TYPE_STRING, name,
                                          LIGMA_TYPE_BRUSH_GENERATED_SHAPE, shape_in,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-brush-set-shape",
                                              args);
  ligma_value_array_unref (args);

  if (LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS)
    shape_out = LIGMA_VALUES_GET_ENUM (return_vals, 1);

  ligma_value_array_unref (return_vals);

  return shape_out;
}

/**
 * ligma_brush_get_radius:
 * @name: The brush name.
 *
 * Gets the radius of a generated brush.
 *
 * This procedure gets the radius value for a generated brush. If
 * called for any other type of brush, it does not succeed.
 *
 * Returns: The radius of the brush in pixels.
 *
 * Since: 2.4
 **/
gdouble
ligma_brush_get_radius (const gchar *name)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gdouble radius = 0.0;

  args = ligma_value_array_new_from_types (NULL,
                                          G_TYPE_STRING, name,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-brush-get-radius",
                                              args);
  ligma_value_array_unref (args);

  if (LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS)
    radius = LIGMA_VALUES_GET_DOUBLE (return_vals, 1);

  ligma_value_array_unref (return_vals);

  return radius;
}

/**
 * ligma_brush_set_radius:
 * @name: The brush name.
 * @radius_in: The desired brush radius in pixel.
 *
 * Sets the radius of a generated brush.
 *
 * This procedure sets the radius for a generated brush. If called for
 * any other type of brush, it does not succeed.
 *
 * Returns: The brush radius actually assigned.
 *
 * Since: 2.4
 **/
gdouble
ligma_brush_set_radius (const gchar *name,
                       gdouble      radius_in)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gdouble radius_out = 0.0;

  args = ligma_value_array_new_from_types (NULL,
                                          G_TYPE_STRING, name,
                                          G_TYPE_DOUBLE, radius_in,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-brush-set-radius",
                                              args);
  ligma_value_array_unref (args);

  if (LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS)
    radius_out = LIGMA_VALUES_GET_DOUBLE (return_vals, 1);

  ligma_value_array_unref (return_vals);

  return radius_out;
}

/**
 * ligma_brush_get_spikes:
 * @name: The brush name.
 *
 * Gets the number of spikes for a generated brush.
 *
 * This procedure gets the number of spikes for a generated brush. If
 * called for any other type of brush, it does not succeed.
 *
 * Returns: The number of spikes on the brush.
 *
 * Since: 2.4
 **/
gint
ligma_brush_get_spikes (const gchar *name)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gint spikes = 0;

  args = ligma_value_array_new_from_types (NULL,
                                          G_TYPE_STRING, name,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-brush-get-spikes",
                                              args);
  ligma_value_array_unref (args);

  if (LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS)
    spikes = LIGMA_VALUES_GET_INT (return_vals, 1);

  ligma_value_array_unref (return_vals);

  return spikes;
}

/**
 * ligma_brush_set_spikes:
 * @name: The brush name.
 * @spikes_in: The desired number of spikes.
 *
 * Sets the number of spikes for a generated brush.
 *
 * This procedure sets the number of spikes for a generated brush. If
 * called for any other type of brush, it does not succeed.
 *
 * Returns: The number of spikes actually assigned.
 *
 * Since: 2.4
 **/
gint
ligma_brush_set_spikes (const gchar *name,
                       gint         spikes_in)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gint spikes_out = 0;

  args = ligma_value_array_new_from_types (NULL,
                                          G_TYPE_STRING, name,
                                          G_TYPE_INT, spikes_in,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-brush-set-spikes",
                                              args);
  ligma_value_array_unref (args);

  if (LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS)
    spikes_out = LIGMA_VALUES_GET_INT (return_vals, 1);

  ligma_value_array_unref (return_vals);

  return spikes_out;
}

/**
 * ligma_brush_get_hardness:
 * @name: The brush name.
 *
 * Gets the hardness of a generated brush.
 *
 * This procedure gets the hardness of a generated brush. The hardness
 * of a brush is the amount its intensity fades at the outside edge, as
 * a float between 0.0 and 1.0. If called for any other type of brush,
 * the function does not succeed.
 *
 * Returns: The hardness of the brush.
 *
 * Since: 2.4
 **/
gdouble
ligma_brush_get_hardness (const gchar *name)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gdouble hardness = 0.0;

  args = ligma_value_array_new_from_types (NULL,
                                          G_TYPE_STRING, name,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-brush-get-hardness",
                                              args);
  ligma_value_array_unref (args);

  if (LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS)
    hardness = LIGMA_VALUES_GET_DOUBLE (return_vals, 1);

  ligma_value_array_unref (return_vals);

  return hardness;
}

/**
 * ligma_brush_set_hardness:
 * @name: The brush name.
 * @hardness_in: The desired brush hardness.
 *
 * Sets the hardness of a generated brush.
 *
 * This procedure sets the hardness for a generated brush. If called
 * for any other type of brush, it does not succeed. The value should
 * be a float between 0.0 and 1.0.
 *
 * Returns: The brush hardness actually assigned.
 *
 * Since: 2.4
 **/
gdouble
ligma_brush_set_hardness (const gchar *name,
                         gdouble      hardness_in)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gdouble hardness_out = 0.0;

  args = ligma_value_array_new_from_types (NULL,
                                          G_TYPE_STRING, name,
                                          G_TYPE_DOUBLE, hardness_in,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-brush-set-hardness",
                                              args);
  ligma_value_array_unref (args);

  if (LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS)
    hardness_out = LIGMA_VALUES_GET_DOUBLE (return_vals, 1);

  ligma_value_array_unref (return_vals);

  return hardness_out;
}

/**
 * ligma_brush_get_aspect_ratio:
 * @name: The brush name.
 *
 * Gets the aspect ratio of a generated brush.
 *
 * This procedure gets the aspect ratio of a generated brush. If called
 * for any other type of brush, it does not succeed. The return value
 * is a float between 0.0 and 1000.0.
 *
 * Returns: The aspect ratio of the brush.
 *
 * Since: 2.4
 **/
gdouble
ligma_brush_get_aspect_ratio (const gchar *name)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gdouble aspect_ratio = 0.0;

  args = ligma_value_array_new_from_types (NULL,
                                          G_TYPE_STRING, name,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-brush-get-aspect-ratio",
                                              args);
  ligma_value_array_unref (args);

  if (LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS)
    aspect_ratio = LIGMA_VALUES_GET_DOUBLE (return_vals, 1);

  ligma_value_array_unref (return_vals);

  return aspect_ratio;
}

/**
 * ligma_brush_set_aspect_ratio:
 * @name: The brush name.
 * @aspect_ratio_in: The desired brush aspect ratio.
 *
 * Sets the aspect ratio of a generated brush.
 *
 * This procedure sets the aspect ratio for a generated brush. If
 * called for any other type of brush, it does not succeed. The value
 * should be a float between 0.0 and 1000.0.
 *
 * Returns: The brush aspect ratio actually assigned.
 *
 * Since: 2.4
 **/
gdouble
ligma_brush_set_aspect_ratio (const gchar *name,
                             gdouble      aspect_ratio_in)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gdouble aspect_ratio_out = 0.0;

  args = ligma_value_array_new_from_types (NULL,
                                          G_TYPE_STRING, name,
                                          G_TYPE_DOUBLE, aspect_ratio_in,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-brush-set-aspect-ratio",
                                              args);
  ligma_value_array_unref (args);

  if (LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS)
    aspect_ratio_out = LIGMA_VALUES_GET_DOUBLE (return_vals, 1);

  ligma_value_array_unref (return_vals);

  return aspect_ratio_out;
}

/**
 * ligma_brush_get_angle:
 * @name: The brush name.
 *
 * Gets the rotation angle of a generated brush.
 *
 * This procedure gets the angle of rotation for a generated brush. If
 * called for any other type of brush, it does not succeed.
 *
 * Returns: The rotation angle of the brush in degree.
 *
 * Since: 2.4
 **/
gdouble
ligma_brush_get_angle (const gchar *name)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gdouble angle = 0.0;

  args = ligma_value_array_new_from_types (NULL,
                                          G_TYPE_STRING, name,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-brush-get-angle",
                                              args);
  ligma_value_array_unref (args);

  if (LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS)
    angle = LIGMA_VALUES_GET_DOUBLE (return_vals, 1);

  ligma_value_array_unref (return_vals);

  return angle;
}

/**
 * ligma_brush_set_angle:
 * @name: The brush name.
 * @angle_in: The desired brush rotation angle in degree.
 *
 * Sets the rotation angle of a generated brush.
 *
 * This procedure sets the rotation angle for a generated brush. If
 * called for any other type of brush, it does not succeed.
 *
 * Returns: The brush rotation angle actually assigned.
 *
 * Since: 2.4
 **/
gdouble
ligma_brush_set_angle (const gchar *name,
                      gdouble      angle_in)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gdouble angle_out = 0.0;

  args = ligma_value_array_new_from_types (NULL,
                                          G_TYPE_STRING, name,
                                          G_TYPE_DOUBLE, angle_in,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-brush-set-angle",
                                              args);
  ligma_value_array_unref (args);

  if (LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS)
    angle_out = LIGMA_VALUES_GET_DOUBLE (return_vals, 1);

  ligma_value_array_unref (return_vals);

  return angle_out;
}
