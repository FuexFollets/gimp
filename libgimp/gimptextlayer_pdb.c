/* LIBLIGMA - The LIGMA Library
 * Copyright (C) 1995-2003 Peter Mattis and Spencer Kimball
 *
 * ligmatextlayer_pdb.c
 *
 * This library is free software: you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library.  If not, see
 * <https://www.gnu.org/licenses/>.
 */

/* NOTE: This file is auto-generated by pdbgen.pl */

#include "config.h"

#include "stamp-pdbgen.h"

#include "ligma.h"


/**
 * SECTION: ligmatextlayer
 * @title: ligmatextlayer
 * @short_description: Functions for querying and manipulating text layers.
 *
 * Functions for querying and manipulating text layers.
 **/


/**
 * _ligma_text_layer_new:
 * @image: The image.
 * @text: The text to generate (in UTF-8 encoding).
 * @fontname: The name of the font.
 * @size: The size of text in either pixels or points.
 * @unit: The units of specified size.
 *
 * Creates a new text layer.
 *
 * This procedure creates a new text layer. The arguments are kept as
 * simple as necessary for the normal case. All text attributes,
 * however, can be modified with the appropriate
 * ligma_text_layer_set_*() procedures. The new layer still needs to be
 * added to the image, as this is not automatic. Add the new layer
 * using ligma_image_insert_layer().
 *
 * Returns: (transfer none): The new text layer.
 *
 * Since: 2.6
 **/
LigmaTextLayer *
_ligma_text_layer_new (LigmaImage   *image,
                      const gchar *text,
                      const gchar *fontname,
                      gdouble      size,
                      LigmaUnit     unit)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  LigmaTextLayer *layer = NULL;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_IMAGE, image,
                                          G_TYPE_STRING, text,
                                          G_TYPE_STRING, fontname,
                                          G_TYPE_DOUBLE, size,
                                          LIGMA_TYPE_UNIT, unit,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-text-layer-new",
                                              args);
  ligma_value_array_unref (args);

  if (LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS)
    layer = LIGMA_VALUES_GET_TEXT_LAYER (return_vals, 1);

  ligma_value_array_unref (return_vals);

  return layer;
}

/**
 * ligma_text_layer_get_text:
 * @layer: The text layer.
 *
 * Get the text from a text layer as string.
 *
 * This procedure returns the text from a text layer as a string.
 *
 * Returns: (transfer full): The text from the specified text layer.
 *          The returned value must be freed with g_free().
 *
 * Since: 2.6
 **/
gchar *
ligma_text_layer_get_text (LigmaTextLayer *layer)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gchar *text = NULL;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_TEXT_LAYER, layer,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-text-layer-get-text",
                                              args);
  ligma_value_array_unref (args);

  if (LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS)
    text = LIGMA_VALUES_DUP_STRING (return_vals, 1);

  ligma_value_array_unref (return_vals);

  return text;
}

/**
 * ligma_text_layer_set_text:
 * @layer: The text layer.
 * @text: The new text to set.
 *
 * Set the text of a text layer.
 *
 * This procedure changes the text of a text layer.
 *
 * Returns: TRUE on success.
 *
 * Since: 2.6
 **/
gboolean
ligma_text_layer_set_text (LigmaTextLayer *layer,
                          const gchar   *text)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gboolean success = TRUE;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_TEXT_LAYER, layer,
                                          G_TYPE_STRING, text,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-text-layer-set-text",
                                              args);
  ligma_value_array_unref (args);

  success = LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS;

  ligma_value_array_unref (return_vals);

  return success;
}

/**
 * ligma_text_layer_get_markup:
 * @layer: The text layer.
 *
 * Get the markup from a text layer as string.
 *
 * This procedure returns the markup of the styles from a text layer.
 * The markup will be in the form of Pango's markup - See
 * https://www.pango.org/ for more information about Pango and its
 * markup.
 *
 * Returns: (transfer full):
 *          The markup which represents the style of the specified text layer.
 *          The returned value must be freed with g_free().
 *
 * Since: 2.8
 **/
gchar *
ligma_text_layer_get_markup (LigmaTextLayer *layer)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gchar *markup = NULL;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_TEXT_LAYER, layer,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-text-layer-get-markup",
                                              args);
  ligma_value_array_unref (args);

  if (LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS)
    markup = LIGMA_VALUES_DUP_STRING (return_vals, 1);

  ligma_value_array_unref (return_vals);

  return markup;
}

/**
 * ligma_text_layer_set_markup:
 * @layer: The text layer.
 * @markup: The new markup to set.
 *
 * Set the markup for a text layer from a string.
 *
 * This procedure sets the markup of the styles for a text layer. The
 * markup should be in the form of Pango's markup - See
 * https://docs.gtk.org/Pango/pango_markup.html for a reference.
 * Note that LIGMA's text tool does not support all of Pango markup. Any
 * unsupported markup will still be applied to your text layer, yet
 * would be dropped as soon as you edit text with the tool.
 *
 * Returns: TRUE on success.
 *
 * Since: 3.0
 **/
gboolean
ligma_text_layer_set_markup (LigmaTextLayer *layer,
                            const gchar   *markup)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gboolean success = TRUE;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_TEXT_LAYER, layer,
                                          G_TYPE_STRING, markup,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-text-layer-set-markup",
                                              args);
  ligma_value_array_unref (args);

  success = LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS;

  ligma_value_array_unref (return_vals);

  return success;
}

/**
 * ligma_text_layer_get_font:
 * @layer: The text layer.
 *
 * Get the font from a text layer as string.
 *
 * This procedure returns the name of the font from a text layer.
 *
 * Returns: (transfer full):
 *          The font which is used in the specified text layer.
 *          The returned value must be freed with g_free().
 *
 * Since: 2.6
 **/
gchar *
ligma_text_layer_get_font (LigmaTextLayer *layer)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gchar *font = NULL;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_TEXT_LAYER, layer,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-text-layer-get-font",
                                              args);
  ligma_value_array_unref (args);

  if (LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS)
    font = LIGMA_VALUES_DUP_STRING (return_vals, 1);

  ligma_value_array_unref (return_vals);

  return font;
}

/**
 * ligma_text_layer_set_font:
 * @layer: The text layer.
 * @font: The new font to use.
 *
 * Set the font of a text layer.
 *
 * This procedure modifies the font used in the specified text layer.
 *
 * Returns: TRUE on success.
 *
 * Since: 2.6
 **/
gboolean
ligma_text_layer_set_font (LigmaTextLayer *layer,
                          const gchar   *font)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gboolean success = TRUE;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_TEXT_LAYER, layer,
                                          G_TYPE_STRING, font,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-text-layer-set-font",
                                              args);
  ligma_value_array_unref (args);

  success = LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS;

  ligma_value_array_unref (return_vals);

  return success;
}

/**
 * ligma_text_layer_get_font_size:
 * @layer: The text layer.
 * @unit: (out) (transfer none): The unit used for the font size.
 *
 * Get the font size from a text layer.
 *
 * This procedure returns the size of the font which is used in a text
 * layer. You will receive the size as a float 'font-size' in 'unit'
 * units.
 *
 * Returns: The font size.
 *
 * Since: 2.6
 **/
gdouble
ligma_text_layer_get_font_size (LigmaTextLayer *layer,
                               LigmaUnit      *unit)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gdouble font_size = 0.0;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_TEXT_LAYER, layer,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-text-layer-get-font-size",
                                              args);
  ligma_value_array_unref (args);

  if (LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS)
    {
      font_size = LIGMA_VALUES_GET_DOUBLE (return_vals, 1);
      *unit = LIGMA_VALUES_GET_INT (return_vals, 2);
    }

  ligma_value_array_unref (return_vals);

  return font_size;
}

/**
 * ligma_text_layer_set_font_size:
 * @layer: The text layer.
 * @font_size: The font size.
 * @unit: The unit to use for the font size.
 *
 * Set the font size.
 *
 * This procedure changes the font size of a text layer. The size of
 * your font will be a double 'font-size' of 'unit' units.
 *
 * Returns: TRUE on success.
 *
 * Since: 2.6
 **/
gboolean
ligma_text_layer_set_font_size (LigmaTextLayer *layer,
                               gdouble        font_size,
                               LigmaUnit       unit)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gboolean success = TRUE;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_TEXT_LAYER, layer,
                                          G_TYPE_DOUBLE, font_size,
                                          LIGMA_TYPE_UNIT, unit,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-text-layer-set-font-size",
                                              args);
  ligma_value_array_unref (args);

  success = LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS;

  ligma_value_array_unref (return_vals);

  return success;
}

/**
 * ligma_text_layer_get_antialias:
 * @layer: The text layer.
 *
 * Check if antialiasing is used in the text layer.
 *
 * This procedure checks if antialiasing is enabled in the specified
 * text layer.
 *
 * Returns: A flag which is true if antialiasing is used for rendering the font in the text layer.
 *
 * Since: 2.6
 **/
gboolean
ligma_text_layer_get_antialias (LigmaTextLayer *layer)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gboolean antialias = FALSE;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_TEXT_LAYER, layer,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-text-layer-get-antialias",
                                              args);
  ligma_value_array_unref (args);

  if (LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS)
    antialias = LIGMA_VALUES_GET_BOOLEAN (return_vals, 1);

  ligma_value_array_unref (return_vals);

  return antialias;
}

/**
 * ligma_text_layer_set_antialias:
 * @layer: The text layer.
 * @antialias: Enable/disable antialiasing of the text.
 *
 * Enable/disable anti-aliasing in a text layer.
 *
 * This procedure enables or disables anti-aliasing of the text in a
 * text layer.
 *
 * Returns: TRUE on success.
 *
 * Since: 2.6
 **/
gboolean
ligma_text_layer_set_antialias (LigmaTextLayer *layer,
                               gboolean       antialias)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gboolean success = TRUE;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_TEXT_LAYER, layer,
                                          G_TYPE_BOOLEAN, antialias,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-text-layer-set-antialias",
                                              args);
  ligma_value_array_unref (args);

  success = LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS;

  ligma_value_array_unref (return_vals);

  return success;
}

/**
 * ligma_text_layer_get_hint_style:
 * @layer: The text layer.
 *
 * Get information about hinting in the specified text layer.
 *
 * This procedure provides information about the hinting that is being
 * used in a text layer. Hinting can be optimized for fidelity or
 * contrast or it can be turned entirely off.
 *
 * Returns: The hint style used for font outlines.
 *
 * Since: 2.8
 **/
LigmaTextHintStyle
ligma_text_layer_get_hint_style (LigmaTextLayer *layer)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  LigmaTextHintStyle style = 0;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_TEXT_LAYER, layer,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-text-layer-get-hint-style",
                                              args);
  ligma_value_array_unref (args);

  if (LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS)
    style = LIGMA_VALUES_GET_ENUM (return_vals, 1);

  ligma_value_array_unref (return_vals);

  return style;
}

/**
 * ligma_text_layer_set_hint_style:
 * @layer: The text layer.
 * @style: The new hint style.
 *
 * Control how font outlines are hinted in a text layer.
 *
 * This procedure sets the hint style for font outlines in a text
 * layer. This controls whether to fit font outlines to the pixel grid,
 * and if so, whether to optimize for fidelity or contrast.
 *
 * Returns: TRUE on success.
 *
 * Since: 2.8
 **/
gboolean
ligma_text_layer_set_hint_style (LigmaTextLayer     *layer,
                                LigmaTextHintStyle  style)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gboolean success = TRUE;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_TEXT_LAYER, layer,
                                          LIGMA_TYPE_TEXT_HINT_STYLE, style,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-text-layer-set-hint-style",
                                              args);
  ligma_value_array_unref (args);

  success = LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS;

  ligma_value_array_unref (return_vals);

  return success;
}

/**
 * ligma_text_layer_get_kerning:
 * @layer: The text layer.
 *
 * Check if kerning is used in the text layer.
 *
 * This procedure checks if kerning is enabled in the specified text
 * layer.
 *
 * Returns: A flag which is true if kerning is used in the text layer.
 *
 * Since: 2.6
 **/
gboolean
ligma_text_layer_get_kerning (LigmaTextLayer *layer)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gboolean kerning = FALSE;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_TEXT_LAYER, layer,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-text-layer-get-kerning",
                                              args);
  ligma_value_array_unref (args);

  if (LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS)
    kerning = LIGMA_VALUES_GET_BOOLEAN (return_vals, 1);

  ligma_value_array_unref (return_vals);

  return kerning;
}

/**
 * ligma_text_layer_set_kerning:
 * @layer: The text layer.
 * @kerning: Enable/disable kerning in the text.
 *
 * Enable/disable kerning in a text layer.
 *
 * This procedure enables or disables kerning in a text layer.
 *
 * Returns: TRUE on success.
 *
 * Since: 2.6
 **/
gboolean
ligma_text_layer_set_kerning (LigmaTextLayer *layer,
                             gboolean       kerning)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gboolean success = TRUE;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_TEXT_LAYER, layer,
                                          G_TYPE_BOOLEAN, kerning,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-text-layer-set-kerning",
                                              args);
  ligma_value_array_unref (args);

  success = LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS;

  ligma_value_array_unref (return_vals);

  return success;
}

/**
 * ligma_text_layer_get_language:
 * @layer: The text layer.
 *
 * Get the language used in the text layer.
 *
 * This procedure returns the language string which is set for the text
 * in the text layer.
 *
 * Returns: (transfer full): The language used in the text layer.
 *          The returned value must be freed with g_free().
 *
 * Since: 2.6
 **/
gchar *
ligma_text_layer_get_language (LigmaTextLayer *layer)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gchar *language = NULL;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_TEXT_LAYER, layer,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-text-layer-get-language",
                                              args);
  ligma_value_array_unref (args);

  if (LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS)
    language = LIGMA_VALUES_DUP_STRING (return_vals, 1);

  ligma_value_array_unref (return_vals);

  return language;
}

/**
 * ligma_text_layer_set_language:
 * @layer: The text layer.
 * @language: The new language to use for the text layer.
 *
 * Set the language of the text layer.
 *
 * This procedure sets the language of the text in text layer. For some
 * scripts the language has an influence of how the text is rendered.
 *
 * Returns: TRUE on success.
 *
 * Since: 2.6
 **/
gboolean
ligma_text_layer_set_language (LigmaTextLayer *layer,
                              const gchar   *language)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gboolean success = TRUE;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_TEXT_LAYER, layer,
                                          G_TYPE_STRING, language,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-text-layer-set-language",
                                              args);
  ligma_value_array_unref (args);

  success = LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS;

  ligma_value_array_unref (return_vals);

  return success;
}

/**
 * ligma_text_layer_get_base_direction:
 * @layer: The text layer.
 *
 * Get the base direction used for rendering the text layer.
 *
 * This procedure returns the base direction used for rendering the
 * text in the text layer
 *
 * Returns: The based direction used for the text layer.
 *
 * Since: 2.6
 **/
LigmaTextDirection
ligma_text_layer_get_base_direction (LigmaTextLayer *layer)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  LigmaTextDirection direction = 0;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_TEXT_LAYER, layer,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-text-layer-get-base-direction",
                                              args);
  ligma_value_array_unref (args);

  if (LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS)
    direction = LIGMA_VALUES_GET_ENUM (return_vals, 1);

  ligma_value_array_unref (return_vals);

  return direction;
}

/**
 * ligma_text_layer_set_base_direction:
 * @layer: The text layer.
 * @direction: The base direction of the text.
 *
 * Set the base direction in the text layer.
 *
 * This procedure sets the base direction used in applying the Unicode
 * bidirectional algorithm when rendering the text.
 *
 * Returns: TRUE on success.
 *
 * Since: 2.6
 **/
gboolean
ligma_text_layer_set_base_direction (LigmaTextLayer     *layer,
                                    LigmaTextDirection  direction)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gboolean success = TRUE;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_TEXT_LAYER, layer,
                                          LIGMA_TYPE_TEXT_DIRECTION, direction,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-text-layer-set-base-direction",
                                              args);
  ligma_value_array_unref (args);

  success = LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS;

  ligma_value_array_unref (return_vals);

  return success;
}

/**
 * ligma_text_layer_get_justification:
 * @layer: The text layer.
 *
 * Get the text justification information of the text layer.
 *
 * This procedure returns the alignment of the lines in the text layer
 * relative to each other.
 *
 * Returns: The justification used in the text layer.
 *
 * Since: 2.6
 **/
LigmaTextJustification
ligma_text_layer_get_justification (LigmaTextLayer *layer)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  LigmaTextJustification justify = 0;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_TEXT_LAYER, layer,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-text-layer-get-justification",
                                              args);
  ligma_value_array_unref (args);

  if (LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS)
    justify = LIGMA_VALUES_GET_ENUM (return_vals, 1);

  ligma_value_array_unref (return_vals);

  return justify;
}

/**
 * ligma_text_layer_set_justification:
 * @layer: The text layer.
 * @justify: The justification for your text.
 *
 * Set the justification of the text in a text layer.
 *
 * This procedure sets the alignment of the lines in the text layer
 * relative to each other.
 *
 * Returns: TRUE on success.
 *
 * Since: 2.6
 **/
gboolean
ligma_text_layer_set_justification (LigmaTextLayer         *layer,
                                   LigmaTextJustification  justify)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gboolean success = TRUE;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_TEXT_LAYER, layer,
                                          LIGMA_TYPE_TEXT_JUSTIFICATION, justify,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-text-layer-set-justification",
                                              args);
  ligma_value_array_unref (args);

  success = LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS;

  ligma_value_array_unref (return_vals);

  return success;
}

/**
 * ligma_text_layer_get_color:
 * @layer: The text layer.
 * @color: (out caller-allocates): The color of the text.
 *
 * Get the color of the text in a text layer.
 *
 * This procedure returns the color of the text in a text layer.
 *
 * Returns: TRUE on success.
 *
 * Since: 2.6
 **/
gboolean
ligma_text_layer_get_color (LigmaTextLayer *layer,
                           LigmaRGB       *color)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gboolean success = TRUE;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_TEXT_LAYER, layer,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-text-layer-get-color",
                                              args);
  ligma_value_array_unref (args);

  success = LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS;

  if (success)
    LIGMA_VALUES_GET_RGB (return_vals, 1, &*color);

  ligma_value_array_unref (return_vals);

  return success;
}

/**
 * ligma_text_layer_set_color:
 * @layer: The text layer.
 * @color: The color to use for the text.
 *
 * Set the color of the text in the text layer.
 *
 * This procedure sets the text color in the text layer 'layer'.
 *
 * Returns: TRUE on success.
 *
 * Since: 2.6
 **/
gboolean
ligma_text_layer_set_color (LigmaTextLayer *layer,
                           const LigmaRGB *color)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gboolean success = TRUE;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_TEXT_LAYER, layer,
                                          LIGMA_TYPE_RGB, color,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-text-layer-set-color",
                                              args);
  ligma_value_array_unref (args);

  success = LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS;

  ligma_value_array_unref (return_vals);

  return success;
}

/**
 * ligma_text_layer_get_indent:
 * @layer: The text layer.
 *
 * Get the line indentation of text layer.
 *
 * This procedure returns the indentation of the first line in a text
 * layer.
 *
 * Returns: The indentation value of the first line.
 *
 * Since: 2.6
 **/
gdouble
ligma_text_layer_get_indent (LigmaTextLayer *layer)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gdouble indent = 0.0;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_TEXT_LAYER, layer,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-text-layer-get-indent",
                                              args);
  ligma_value_array_unref (args);

  if (LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS)
    indent = LIGMA_VALUES_GET_DOUBLE (return_vals, 1);

  ligma_value_array_unref (return_vals);

  return indent;
}

/**
 * ligma_text_layer_set_indent:
 * @layer: The text layer.
 * @indent: The indentation for the first line.
 *
 * Set the indentation of the first line in a text layer.
 *
 * This procedure sets the indentation of the first line in the text
 * layer.
 *
 * Returns: TRUE on success.
 *
 * Since: 2.6
 **/
gboolean
ligma_text_layer_set_indent (LigmaTextLayer *layer,
                            gdouble        indent)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gboolean success = TRUE;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_TEXT_LAYER, layer,
                                          G_TYPE_DOUBLE, indent,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-text-layer-set-indent",
                                              args);
  ligma_value_array_unref (args);

  success = LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS;

  ligma_value_array_unref (return_vals);

  return success;
}

/**
 * ligma_text_layer_get_line_spacing:
 * @layer: The text layer.
 *
 * Get the spacing between lines of text.
 *
 * This procedure returns the line-spacing between lines of text in a
 * text layer.
 *
 * Returns: The line-spacing value.
 *
 * Since: 2.6
 **/
gdouble
ligma_text_layer_get_line_spacing (LigmaTextLayer *layer)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gdouble line_spacing = 0.0;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_TEXT_LAYER, layer,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-text-layer-get-line-spacing",
                                              args);
  ligma_value_array_unref (args);

  if (LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS)
    line_spacing = LIGMA_VALUES_GET_DOUBLE (return_vals, 1);

  ligma_value_array_unref (return_vals);

  return line_spacing;
}

/**
 * ligma_text_layer_set_line_spacing:
 * @layer: The text layer.
 * @line_spacing: The additional line spacing to use.
 *
 * Adjust the line spacing in a text layer.
 *
 * This procedure sets the additional spacing used between lines a text
 * layer.
 *
 * Returns: TRUE on success.
 *
 * Since: 2.6
 **/
gboolean
ligma_text_layer_set_line_spacing (LigmaTextLayer *layer,
                                  gdouble        line_spacing)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gboolean success = TRUE;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_TEXT_LAYER, layer,
                                          G_TYPE_DOUBLE, line_spacing,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-text-layer-set-line-spacing",
                                              args);
  ligma_value_array_unref (args);

  success = LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS;

  ligma_value_array_unref (return_vals);

  return success;
}

/**
 * ligma_text_layer_get_letter_spacing:
 * @layer: The text layer.
 *
 * Get the letter spacing used in a text layer.
 *
 * This procedure returns the additional spacing between the single
 * glyphs in a text layer.
 *
 * Returns: The letter-spacing value.
 *
 * Since: 2.6
 **/
gdouble
ligma_text_layer_get_letter_spacing (LigmaTextLayer *layer)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gdouble letter_spacing = 0.0;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_TEXT_LAYER, layer,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-text-layer-get-letter-spacing",
                                              args);
  ligma_value_array_unref (args);

  if (LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS)
    letter_spacing = LIGMA_VALUES_GET_DOUBLE (return_vals, 1);

  ligma_value_array_unref (return_vals);

  return letter_spacing;
}

/**
 * ligma_text_layer_set_letter_spacing:
 * @layer: The text layer.
 * @letter_spacing: The additional letter spacing to use.
 *
 * Adjust the letter spacing in a text layer.
 *
 * This procedure sets the additional spacing between the single glyphs
 * in a text layer.
 *
 * Returns: TRUE on success.
 *
 * Since: 2.6
 **/
gboolean
ligma_text_layer_set_letter_spacing (LigmaTextLayer *layer,
                                    gdouble        letter_spacing)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gboolean success = TRUE;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_TEXT_LAYER, layer,
                                          G_TYPE_DOUBLE, letter_spacing,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-text-layer-set-letter-spacing",
                                              args);
  ligma_value_array_unref (args);

  success = LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS;

  ligma_value_array_unref (return_vals);

  return success;
}

/**
 * ligma_text_layer_resize:
 * @layer: The text layer.
 * @width: The new box width in pixels.
 * @height: The new box height in pixels.
 *
 * Resize the box of a text layer.
 *
 * This procedure changes the width and height of a text layer while
 * keeping it as a text layer and not converting it to a bitmap like
 * ligma_layer_resize() would do.
 *
 * Returns: TRUE on success.
 *
 * Since: 2.8
 **/
gboolean
ligma_text_layer_resize (LigmaTextLayer *layer,
                        gdouble        width,
                        gdouble        height)
{
  LigmaValueArray *args;
  LigmaValueArray *return_vals;
  gboolean success = TRUE;

  args = ligma_value_array_new_from_types (NULL,
                                          LIGMA_TYPE_TEXT_LAYER, layer,
                                          G_TYPE_DOUBLE, width,
                                          G_TYPE_DOUBLE, height,
                                          G_TYPE_NONE);

  return_vals = ligma_pdb_run_procedure_array (ligma_get_pdb (),
                                              "ligma-text-layer-resize",
                                              args);
  ligma_value_array_unref (args);

  success = LIGMA_VALUES_GET_ENUM (return_vals, 0) == LIGMA_PDB_SUCCESS;

  ligma_value_array_unref (return_vals);

  return success;
}
