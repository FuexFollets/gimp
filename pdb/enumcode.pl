#!/usr/bin/perl -w

# LIGMA - The GNU Image Manipulation Program
# Copyright (C) 1999-2003 Manish Singh <yosh@ligma.org>

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUTFILE ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

BEGIN {
    $srcdir   = $ENV{srcdir}  || '.';
    $destdir  = $ENV{destdir} || '.';
    $builddir = $ENV{builddir} || '.';
}

use lib $srcdir;

require 'enums.pl';
require 'util.pl';

*enums = \%Ligma::CodeGen::enums::enums;

*write_file = \&Ligma::CodeGen::util::write_file;
*FILE_EXT   = \$Ligma::CodeGen::util::FILE_EXT;

my $enumfile = "$builddir/libligma/ligmaenums.h$FILE_EXT";
open ENUMFILE, "> $enumfile" or die "Can't open $enumfile: $!\n";

print ENUMFILE <<'LGPL';
/* LIBLIGMA - The LIGMA Library
 * Copyright (C) 1995-2003 Peter Mattis and Spencer Kimball
 *
 * This library is free software: you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library.  If not, see
 * <https://www.gnu.org/licenses/>.
 */

/* NOTE: This file is autogenerated by enumcode.pl */

LGPL

my $guard = "__LIGMA_ENUMS_H__";
print ENUMFILE <<HEADER;
#ifndef $guard
#define $guard

G_BEGIN_DECLS

HEADER

foreach (sort keys %enums) {
    if (! ($enums{$_}->{header} =~ /libligma/) &&
	! $enums{$_}->{external}) {
        my $gtype = $func = $_;

	for ($gtype) { s/Ligma//; s/([A-Z][^A-Z]+)/\U$1\E_/g; s/_$// }
	for ($func) { s/Ligma//; s/([A-Z][^A-Z]+)/\L$1\E_/g; s/_$// }

	print ENUMFILE "\n#define LIGMA_TYPE_$gtype (ligma_$func\_get_type ())\n\n";
	print ENUMFILE "GType ligma_$func\_get_type (void) G_GNUC_CONST;\n\n";

	print ENUMFILE "/**\n";
	print ENUMFILE " * $_:\n";

	my $enum = $enums{$_};

	foreach $symbol (@{$enum->{symbols}}) {
	    print ENUMFILE " * @" . $symbol . ": " . $symbol . "\n";
	}

	print ENUMFILE " *\n";
	print ENUMFILE " * Extracted from app/" . $enums{$_}->{header} . "\n";
	print ENUMFILE " **/\n";

	print ENUMFILE "typedef enum\n{\n";

	my $body = "";

	foreach $symbol (@{$enum->{symbols}}) {
	    my $sym = $symbol;
	    $body .= "  $sym";
	    $body .= " = $enum->{mapping}->{$symbol}" if !$enum->{contig};
	    $body .= ",\n";
	}

	$body =~ s/,\n$//s;
	$body .= "\n} ";
	$body .= "$_;\n\n";
	print ENUMFILE $body
    }
}

print ENUMFILE <<HEADER;

void           ligma_enums_init           (void);

const gchar ** ligma_enums_get_type_names (gint *n_type_names);


G_END_DECLS

#endif /* $guard */
HEADER

close ENUMFILE;
&write_file($enumfile, "$destdir/libligma");

$enumfile = "$builddir/libligma/ligmaenums.c.tail$FILE_EXT";
open ENUMFILE, "> $enumfile" or die "Can't open $enumfile: $!\n";

print ENUMFILE <<CODE;

typedef GType (* LigmaGetTypeFunc) (void);

static const LigmaGetTypeFunc get_type_funcs[] =
{
CODE

my $first = 1;
foreach (sort keys %enums) {
    if (! ($_ =~ /LigmaUnit/)) {
	my $enum = $enums{$_};
	my $func = $_;
	my $gegl_enum = ($func =~ /Gegl/);

	for ($func) { s/Ligma//; s/Gegl//; s/PDB/Pdb/;
		      s/([A-Z][^A-Z]+)/\L$1\E_/g; s/_$// }

	print ENUMFILE ",\n" unless $first;

	if ($gegl_enum) {
	    print ENUMFILE "  gegl_$func\_get_type";
	} else {
	    print ENUMFILE "  ligma_$func\_get_type";
	}

	$first = 0;
    }
}
print ENUMFILE "\n" unless $first;

print ENUMFILE <<CODE;
};

static const gchar * const type_names[] =
{
CODE

$first = 1;
foreach (sort keys %enums) {
    if (! ($_ =~ /LigmaUnit/)) {
	my $enum = $enums{$_};
	my $gtype = $_;

	print ENUMFILE ",\n" unless $first;
	print ENUMFILE "  \"$gtype\"";

        $first = 0;
    }
}
print ENUMFILE "\n" unless $first;

print ENUMFILE <<CODE;
};

static gboolean enums_initialized = FALSE;

#if 0
/*  keep around as documentation how to do compat enums  */
GType ligma_convert_dither_type_compat_get_type (void);
#endif

/**
 * ligma_enums_init:
 *
 * This function makes sure all the enum types are registered
 * with the #GType system. This is intended for use by language
 * bindings that need the symbols early, before ligma_main is run.
 * It's not necessary for plug-ins to call this directly, because
 * the normal plug-in initialization code will handle it implicitly.
 *
 * Since: 2.4
 **/
void
ligma_enums_init (void)
{
  const LigmaGetTypeFunc *funcs = get_type_funcs;
#if 0
  GQuark                 quark;
#endif
  gint                   i;

  if (enums_initialized)
    return;

  for (i = 0; i < G_N_ELEMENTS (get_type_funcs); i++, funcs++)
    {
      GType type = (*funcs) ();

      g_type_class_ref (type);
    }

#if 0
  /*  keep around as documentation how to do compat enums  */

  /*  keep compat enum code in sync with app/app.c (app_libs_init)  */
  quark = g_quark_from_static_string ("ligma-compat-enum");

  g_type_set_qdata (LIGMA_TYPE_CONVERT_DITHER_TYPE, quark,
		    (gpointer) ligma_convert_dither_type_compat_get_type ());
#endif

  ligma_base_compat_enums_init ();

  enums_initialized = TRUE;
}

/**
 * ligma_enums_get_type_names:
 * \@n_type_names: (out): return location for the number of names
 *
 * This function gives access to the list of enums registered by libligma.
 * The returned array is static and must not be modified.
 *
 * Returns: (transfer none): an array with type names
 *
 * Since: 2.2
 **/
const gchar **
ligma_enums_get_type_names (gint *n_type_names)
{
  g_return_val_if_fail (n_type_names != NULL, NULL);

  *n_type_names = G_N_ELEMENTS (type_names);

  return (const gchar **) type_names;
}
CODE

close ENUMFILE;
&write_file($enumfile, "$destdir/libligma");
